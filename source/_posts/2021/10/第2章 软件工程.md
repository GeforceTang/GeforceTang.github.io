---
title: 第2章-软件工程
date: 2021-10-25 19:12:56
categories: 架构软考
tags: 架构设计
---


# 初-知识体系
>（1）了解软件开发方法，掌握软件开发模型。
（2）了解需求工程概念，熟悉面向对象分析，掌握结构化分析，掌握需求管理过程。
（3）了解系统建模过程。
（4）了解系统设计的过程，了解人机界面设计和结构化设计，熟悉面向对象设计。
（5）了解软件测试的概念和目标，了解软件测试的原则，熟悉基本的软件测试活动，掌握软件测试的阶段和分类，了解面向对象测试。
（6）了解软件调试方法，区分软件调试与软件测试。
（7）掌握系统转换计划，了解系统维护的概念。
（8）了解软件开发环境与工具。

---
1. 软件开发：
    - 软件开发方法（⭐）
    - 软件开发模型（⭐⭐⭐⭐⭐）
    - 逆向工程（⭐）
    - 净室工程
2. 需求工程：
    - 概述
    - 需求开发（⭐⭐⭐⭐⭐）
    - 需求管理（⭐⭐⭐）
3. 系统建模过程
4. 系统设计：
    - 人机界面设计（⭐）
    - 结构化设计（⭐）
    - 面向对象设计（⭐⭐⭐⭐⭐）
5. 软件测试（⭐⭐⭐⭐⭐）：
    - 概念和目标
    - 软件测试原则
    - 基本测试活动
    - 测试阶段和分类
    - 面向对象测试
6. 软件调试（⭐）：
    - 软件调试方法
    - 软件调试与测试的区别
7. 系统运行与软件维护：
    - 系统转换计划（⭐⭐⭐）
    - 系统维护 （⭐）
8. 软件开发环境与工具（⭐）：
    - 环境机制
    - 工具


# 1-软件开发
## 1.1 软件开发方法（⭐） 
### （1）结构化开发方法
用户至上，自顶向下，逐步分解（求解），严格区分工作阶段，每阶段有任务与成果，强调系统开发过程的整体性和全局性，系统开发过程工程化，文档资料标准化。
#### 优点：
理论基础严密，它的指导思想是用户需求在系统建立之前就能被充分了解和理解。由此可见，结构化方法注重开发过程的整体性和全局性。
#### 缺点：
开发周期长；文档、设计说明繁琐，工作效率低；要求在开发之初全面认识系统的信息需求，充分预料各种可能发生的变化，但这并不十分现实；若用户参与系统开发的积极性没有充分调动，造成系统交接过程不平稳，系统运行与维护管理难度加大。阶段固化，不善变化，适用于需求明确。
### （2）原型法开发方法
适用于**需求不明确**的开发，按功能分-水平原型（界面）、垂直原型（复杂算法），按最终结果分-抛弃式原型、演化式原型。原型法的特点在于原型法对用户的需求是动态响应、逐步纳入的，系统分析、设计与实现都是随着对一个工作模型的不断修改而同时完成的，相互之间并无明显界限，也没有明确分工。系统开发计划就是一个反复修改的过程。适于用户需求开始时定义不清、管理决策方法结构化程度不高的系统开发，开发方法更宜被用户接受；但如果用户配合不好，盲目修改，就会拖延开发过程。
**抛弃型原型**(Throw-It-Away Prototype)，此类原型在系统真正实现以后就放弃不用了。
**进化型原型**(Evolutionary Prototype)，此类原型的构造从目标系统的一个或几个基本需求出发，通过修改和追加功能的过程逐渐丰富，演化成最终系统。
### （3）面向对象方法
最早来源于仿真领域，其特点是系统的描述及信息模型的表示与客观实体相对应，符合人们的思维习惯，有利于系统开发过程中用户与开发人员的交流和沟通，缩短开发周期，提供系统开发的准确性和效率。具有更好的复用性，关键在于建立一个全面、合理、统一的模型，分析、设计、实现三个阶段界限不明确。
用面向对象方法开发软件，通常需要建立三种形式的模型：对象模型（描述系统数据结构）、动态模型（描述系统控制结构）、功能模型（描述系统功能）。
#### 对象模型
对象模型表示静态的、结构化的系统的“数据”性质。对象模型是对模拟客观世界实体的对象以及对象彼此间的关系的映射，描述了系统的静态结构。
#### 动态模型
动态模型表示瞬时的、行为化的系统的“控制”性质，规定了对象模型中对象的合法变化序列。即对象的动态行为。用状态图来描绘对象的状态、触发状态转换的事件、以及对象的行为(对事件的响应)。每个类的动态行为用一张状态图来描绘，各个类的状态图通过共享事件合并起来，从而构成系统的动态模型。
#### 功能模型
功能模型表示变化的系统的“功能”性质，它指明了系统应该“做什么”，故更直接反映了用户对目标系统的需求。功能模型也通常由一组数据流程图表示。在面向对象方法中，数据流程图没有在结构化分析中重要，有时可以省略。

### （4）面向服务的方法
以粗粒度、松散耦合的系统功能为核心，强调系统功能的标准化和构件化，加强了系统的灵活性、可复用性和可演化性。
从概念上讲，SO 方法有三个主要的抽象级别：操作、服务、业务流程
**操作**：代表单个逻辑工作单元（LUW）的事务。执行操作通常会导致读、写或修改一个或多个持久性数据。SOA 操作可以直接与面向对象 (OO) 的方法相比。它们都有特定的结构化接口，并且返回结构化的响应。完全同方法一样，特定操作的执行可能涉及调用附加的操作。操作位于最底层。
**服务**：代表操作的逻辑分组。例如，如果我们将 CustomerProfiling 视为服务，则按照电话号码查找客户、按照名称和邮政编码列出顾客和 保存新客户的数据就代表相关的操作。
**业务流程**：为实现特定业务目标而执行的一组长期运行的动作或活动。业务流程通常包括多个业务调用。业务流程的例子有： 接纳新员工、 出售产品或服务和完成订单。
**SOAD 分为三个层次：基础设计层（底层服务构件）、应用结构层（服务之间的接口和服务级协定）和业务组织层（业务流程建模和服务流程编排）**
**服务建模：分为服务发现、服务规约和服务实现三个阶段**


## 1.2 软件开发模型（⭐⭐⭐⭐⭐） 
### （1）原型模型
典型的原型开发方法模型。适用于需求不明确的场景，可以帮助用户明确需求。
原型的发展方向:
![演化式](/images/系统架构师/软件工程-开发模型演化式.png)
### （2）瀑布模型
瀑布模型是将软件生存周期中的各个活动规定为依线性顺序连接的若干阶段的模型，包括需求分析、设计、编码、运行与维护。
瀑布模型的特点是容易理解，管理成本低，每个阶段都有对应的成果产物，各个阶段有明显的界限划分和顺序要求，一旦发生错误，整个项目推倒重新开始。
适用于需求明确的项目，一般表述为需求明确、或二次开发，或者对于数据处理类型的项目。
### （3）增量模型
融合了瀑布模型的基本成分和原型实现的迭代特征，可以有多个可用版本的发布，核心功能往往最先完成，在此基础上，每轮迭代会有新的增量发布，核心功能可以得到充分测试。强调每一个增量均发布一个可操作的产品。
### （4）螺旋模型
典型特点是引入了风险分析。结合了瀑布模型和演化模型的优点，最主要的特点在于加入了风险分析。它是由制定计划、风险分析、实施工程、客户评估这一循环组成的，它最初从概念项目开始第一个螺旋。属于面向对象开发模型，强调风险引入。
### （5）V 模型
强调测试贯穿项目始终，而不是集中在测试阶段。是一种测试的开发模型。
### （6）喷泉模型
典型的面向对象的模型。特点是迭代、无间隙。会将软件开发划分为多个阶段，但各个阶段无明显界限，并且可以迭代交叉。
### （7）快速应用开发 RAD
概念：RAD 是瀑布模型的一个高速变种，适用比传统生命周期快得多的开发方法，它强调极短的开发周期，通常适用**基于构件**的开发方法获得快速开发。
**过程**：业务建模，数据建模，过程建模，应用生成，测试与交付。
**适用性**：RAD 对模块化要求比较高，如果某项功能不能被模块化，则其构件就会出问题；如果高性能是一个指标，且必须通过调整结构使其适应系统构件才能获得，则 RAD 也有可能不能奏效；RAD 要求开发者和客户必须在很短的时间完成一系列的需求分析，任何一方配合不当都会导致失败；RAD 只能用于管理信息系统的开发，不适合技术风险很高的情况。
### （8）构件组装模型
![组件](/images/系统架构师/软件工程-开发模型组件.png)
### （9）统一过程（在软考中 UP、RUP 都指统一过程）
**典型特点是用例驱动、以架构为中心、迭代和增量。**
统一过程把一个项目分为四个不同的阶段：
**构思阶段（初始/初启阶段）**：包括用户沟通和计划活动两个方面，强调定义和细化用例，并将其作为主要模型。
**细化阶段（精化阶段）**：包括用户沟通和建模活动，重点是创建分析和设计模型，强调类的定义和体系结构的表示。
**构建阶段**：将设计转化为实现，并进行集成和测试。
**移交阶段**：将产品发布给用户进行测试评价，并收集用户的意见，之后再次进行迭代修改产品使之完善。
### （10）敏捷开发
敏捷开发是一种以人为核心、迭代、循序渐进的开发方法，适用于小团队和小项目，具有小步快跑的思想。常见的敏捷开发方法有极限编程法、水晶法、并列争球法和自适应软件开发方法。
![敏捷开发](/images/系统架构师/软件工程-开发模型敏捷开发.png)

**极限编程 XP** 是一种轻量级的开发方法，它提出了四大价值观：沟通、简单、反馈、勇气。五大原则：快速反馈、简单性假设、逐步修改、提倡更改、优质工作。十二个最佳实践：计划游戏、隐喻、小型发布、简单设计、测试先行、重构、结对编程、集体代码所有制、持续集成、每周工作 40 小时、现场客户和编码标准。
**水晶法**强调经常交付，认为每一种不同的项目都需要一套不同的策略、约定和方法论。
**并列争球法**的核心是迭代、增量交付，按照 30 天进行迭代开发交付可实际运行的软件。
**自适应软件开发(ASD 方法)**的核心是三个非线性的，重迭的开发阶段：猜测、合作、学习。
**开放式源码**，这里提到的开放式源码指的是开放源码界所用的一种运作方式。开放式源码项目有一个特别之处，就是程序开发人员在地域上分布很广，这使得它和其他敏捷方法不同，因为一般的敏捷方法都强调项目组成员在同一地点工作。开放源码的一个突出特点就是查错排障(debug)的高度并行性，任何人发现了错误都可将改正源码的“补丁”文件发给维护者。然后由维护者将这些“补丁”或是新增的代码并入源码库。
**Coad 的功用驱动开发方法(FDD-Feature Driven Development)**
FDD 是由 Jeff De Luca 和大师 Peter Coad 提出来的。像其他方法一样，它致力于短时的迭代阶段和可见可用的功能。在 FDD 中，一个迭代周期一般是两周。
在 FDD 中，编程开发人员分成两类：首席程序员和“类”程序员(class owner)。首席程序员是最富有经验的开发人员，他们是项目的协调者、设计者和指导者，而“类”程序员则主要做源码编写。

## 1.3 逆向工程（⭐）
![逆向工程](/images/系统架构师/软件工程-开发模型逆向工程.png)
实现级：包括程序的抽象语法树、符号表、过程的设计表示
结构级：包括反映程序分量之间相互依赖关系的信息，例如调用图、结构图、程序和数据结构
功能级：包括反映程序段功能及程序段之间关系的信息，例如数据和控制流模型
领域级：包括反映程序分量或程序诸实体与应用领域概念之间对应关系的信息，例如实体关系模型

## 1.4 净室工程 
净室即无尘室、洁净室。也就是一个受控污染级别的环境。
使用盒结构规约（或形式化方法）进行分析和设计建模，并且强调将正确性验证，而不是测试，作为发现和消除错误的主要机制。
使用统计的测试来获取认证被交付的软件的可靠性所必需的出错率信息。


# 2-需求工程
## 2.1 概述 
软件需求是指用户对系统在功能、行为、性能、设计约束等方面的期望。
软件需求是指用户解决问题或达到目标所需的条件或能力，是系统或系统部件要满足合同、标准、规范或其他正式规定文档所需具有的条件或能力，以及反映这些条件或能力的文档说明。
![需求工程概述](/images/系统架构师/软件工程-需求工程概述.png)
## 2.2 需求开发 
### 2.2.1 需求获取
#### （1）需求分类
【需求的层次分类】
**业务需求**：是指反应企业或客户对系统高层次的目标要求，通常来自项目投资人、购买产品的客户、客户单位的管理人员、市场营销部门或产品策划部门等。通过业务需求可以确定项目视图和范围，为以后的开发工作奠定了基础。
**用户需求**：描述的是用户的具体目标，或用户要求系统必须能完成的任务。也就是说，用户需求描述了用户能使用系统来做些什么。
**系统需求**：是从系统的角度来说明软件的需求，包括功能需求、非功能需求和设计约束等。
**功能需求**也称为行为需求，它规定了开发人员必须在系统种实现的软件功能，用户利用这些功能来完成任务，满足业务要求。
**性能需求（非功能需求）**是指系统必须具备的属性或品质，又可细分为软件质量属性和其他非功能需求。
**设计约束**也称为限制条件或补充规约，通常是对系统的一些约束说明。
【需求的 QFD 分类】
质量功能部署 QFD 是一种将用户要求转化成软件需求的技术，其目的是最大限度地提升软件工程过程中用户的满意度。QFD 将软件需求分为三类：
**常规需求（基本需求）**：用户认为系统应该做到的功能或性能，实现越多用户会越满意。
**期望需求**：用户想当然认为系统应具备的功能或性能，但并不能正确描述自己想要得到的这些功能或性能需求。如果期望需求没有得到实现，会让用户感到不满意。
**兴奋需求（意外需求）**：是用户要求范围外的功能或性能，实现这些需求用户会更高兴，但不实现也不影响其购买的决策。

#### （2）需求获取方法
**用户访谈**：1 对 1-3，有代表性的用户。用户访谈是最基本的一种需求获取手段，其形式包括结构化和非结构化两种。用户访谈是通过 1 对 1（或 1 对 2，1 对 3）的形式与用户面对面进行沟通，以获取用户需求。用户访谈具有良好的灵活性，有较宽广的应用范围。但是，也存在着许多困难，例如，用户经常较忙，难以安排时间；面谈时信息量大，记录较为困难；沟通需要很多技巧，同时需要系统分析师具有足够的领域知识等。另外，在访谈时，还可能会遇到一些对于企业来说比较机密和敏感的话题。因此，这看似简单的技术，也需要系统分析师具有丰富的经验和较强的沟通能力。
**问卷调查**：用户多，无法一一访谈。与用户访谈相比，问卷调查可以在短时间内，以低廉的代价从大量的回答中收集数据；问卷调查允许回答者匿名填写，大多数用户可能会提供真实信息；问卷调查的结果比较好整理和统计。问卷调查最大的不足就是缺乏灵活性。
**现场观摩**：针对较为复杂的流程和操作。想获取系统某些较为复杂的流程和操作过程，则现场观摩方法比较合适。对于一些较为复杂的流程和操作而言，是比较难以用语言和文字进行表达的，对于这种情况，可以采用到客户的工作现场，一边观察，一边听客户讲解，从而更直观的了解客户需求。
**联合需求计划（JRP**）：高度组织的群体会议，各方参与，成本较高。为了提高需求获取的效率，越来越多的企业倾向于使用小组工作会议来代替大量独立的访谈。联合需求计划（Joint Requirement Planning，JRP）是一个通过高度组织的群体会议来分析企业内的问题并获取需求的过程，它是联合应用开发（Joint Application Development，JAD）的一部分。
**情节串联板**：一系列图片，通过这些图片来讲故事。
**收集资料**：把与系统有关的、对系统开发有益的信息收集起来。
**参加业务实践**：有效地发现问题的本质和寻找解决问题的办法。
**阅读历史文档**：对收集数据性的信息较为有用。
**抽样调查**：降低成本。采样是指从种群中系统地选出有代表性的样本集的过程，通过认真研究所选出的样本集，可以从整体上揭示种群的有用信息。对于信息系统的开发而言，现有系统的文档（文件）就是采样种群。当开始对一个系统做需求分析时，查看现有系统的文档是对系统有初步了解的最好方法。但是，系统分析师应该查看哪些类型的文档，当文档的数据庞大，无法一一研究时，就需要使用采样技术选出有代表性的数据。抽样能够提高需求获取效率，但抽样往往是由系统分析师来抽的，所以会受到他的主观因素影响。
样本大小＝ɑ*（可信度系数/可接受的错误）2
注： ɑ一般取 0.25

### 2.2.2 需求分析
#### 结构化需求分析（SA）（⭐⭐）
（1）结构化分析过程
![需求分析SA](/images/系统架构师/软件工程-需求工程需求分析SA.png)

（2）结构化分析工具-数据流图 DFD
![DFD](/images/系统架构师/软件工程-需求工程需求分析DFD.png)


#### 面向对象需求分析（OOA）（⭐⭐⭐⭐⭐）
##### （1）面向对象基本概念
- 对象：属性（数据）+方法（操作）+对象 ID
- 类（实体类/控制类/边界类）
- 继承与泛化：复用机制
- 封装：隐藏对象的属性和实现细节,仅对外公开接口
- 多态：不同对象收到同样的消息产生不同的结果
- 接口：一种特殊的类，他只有方法定义没有实现
- 重载：一个类可以有多个同名而参数类型不同的方法
- 消息和消息通信：消息是异步通信的

##### （2）UML 图概念
![OOA2](/images/系统架构师/软件工程-需求工程需求分析OOA2.png)

UML 包括两组公共分类，分别是类与对象（类表示概念，而对象表示具体的实体）、接口与实现（接口用来定义契约，而实现就是具体的内容）
- **结构事物**：结构事物在模型中属于最静态的部分，代表概念上或物理上的元素。UML 有七种结构事物，分别是类、接口、协作、用例、活动类、构件和节点。类是描述具有相同属性、方法、关系和语义的对象的集合，一个类实现一个或多个接口；接口是指类或构件提供特定服务的一组操作的集合，接口描述了类或构件的对外的可见的动作；协作定义了交互的操作，是一些角色和其它事物一起工作，提供一些合作的动作，这些动作比事物的总和要大；用例是描述一系列的动作，产生有价值的结果。在模型中用例通常用来组织行为事物。用例是通过协作来实现的；活动类的对象有一个或多个进程或线程。活动类和类很相似，只是它的对象代表的事物的行为和其他事物是同时存在的；构件是物理上或可替换的系统部分，它实现了一个接口集合；节点是一个物理元素，它在运行时存在，代表一个可计算的资源，通常占用一些内存和具有处理能力。一个构件集合一般来说位于一个节点，但有可能从一个节点转到另一个节点。
- **行为事物**：行为事物是 UML 模型中的动态部分，代表时间和空间上的动作。UML 有两种主要的行为事物。第一种是交互（内部活动），**交互**是由一组对象之间在特定上下文中，为达到特定目的而进行的一系列消息交换而组成的动作。交互中组成动作的对象的每个操作都要详细列出，包括消息、动作次序（消息产生的动作）、连接（对象之间的连接）；第二种是状态机，**状态机**由一系列对象的状态组成。
- **分组事物**：分组事物是 UML 模型中组织的部分，可以把它们看成是个盒子，模型可以在其中进行分解。UML 只有一种分组事物，称为包。**包**是一种将有组织的元素分组的机制。与构件不同的是，包纯粹是一种概念上的事物，只存在于开发阶段，而构件可以存在于系统运行阶段。
注释事物：注释事物是 UML 模型的解释部分。

##### （3）UML 图分类
![需求工程需求分析UML2](/images/系统架构师/软件工程-需求工程需求分析UML2.png)
**类图**（class diagram）:类图描述一组类、接口、协作和它们之间的关系。
**对象图**（object diagram）:对象图描述一组对象及它们之间的关系。对象图描述了在类图中所建立的事物实例的静态快照。
**构件图**（component diagram）。构件图描述一个封装的类和它的接口、端口，以及由内嵌的构件和连接件构成的内部结构。构件图用于表示系统的静态设计实现视图。对于由小的部件构建大的系统来说，构件图是很重要的。构件图是类图的变体。一个封装的类和它的接口。
**部署图**（deployment diagram）。部署图描述对运行时的处理节点及在其中生存的构件的配置。部署图给出了架构的静态部署视图，通常一个节点包含一个或多个部署图。软硬件之间映射。
制品图：系统的物理结构。
包图：由模型本身分解而成的组织单元，以及他们之间的依赖关系。
组合结构图
**用例图**：系统与外部参与者的交互。
**顺序图**（sequence diagram，序列图）：顺序图是一种交互图（interaction diagram），它强调对象之间消息发送的顺序，同时显示对象之间的交互。强调按时间顺序。
**通信图**（communication diagram）。协作图。通信图也是一种交互图，它强调收发消息的对象或参与者的结构组织。顺序图和通信图表达了类似的基本概念，但它们所强调的概念不同，顺序图强调的是时序，通信图强调的是对象之间的组织结构（关系）。
定时图：强调实际时间。
交互概览图
**状态图**（state diagram）。状态图描述一个状态机，它由状态、转移、事件和活动组成。状态图给出了对象的动态视图。它对于接口、类或协作的行为建模尤为重要，而且它强调事件导致的对象行为，这非常有助于对反应式系统建模。状态转换变迁
**活动图**（activity diagram）。活动图将进程或其他计算结构展示为计算内部一步步的控制流和数据流。活动图专注于系统的动态视图。它对系统的功能建模和业务流程建模特别重要，并强调对象间的控制流程。类似程序流程图，并行行为。

##### （4）UML 图关系
用例关系包括：包含关系、扩展关系、泛化关系。
- **包含关系**：其中这个提取出来的公共用例称为抽象用例，而把原始用例称为基本用例或基础用例系：当可以从两个或两个以上的用例中提取公共行为时，应该使用包含关系来表示它们。
- **扩展关系**：如果一个用例明显地混合了两种或两种以上的不同场景，即根据情况可能发生多种分支，则可以将这个用例分为一个基本用例和一个或多个扩展用例，这样使描述可能更加清晰。
- **泛化关系**：当多个用例共同拥有一种类似的结构和行为的时候，可以将它们的共性抽象成为父用例，其他的用例作为泛化关系中的子用例。在用例的泛化关系中，子用例是父用例的一种特殊形式，子用例继承了父用例所有的结构、行为和关系。

类图/对象图关系：
- **依赖关系**：一个事物发生变化影响另一个事物。
- **泛化关系**：特殊/一般关系
- **关联关系**：描述了一组链，链是对象之间的连接。
- **•聚合关系**：整体与部分生命周期不同。
- **•组合关系**：整体与部分生命周期相同。
- **实现关系**：接口与类之间的关系

##### （5）“4+1”视图（⭐⭐）
![4+1视图](/images/系统架构师/软件工程-需求工程需求分析4+1.png)

UML 采用 4+1 视图来描述软件和软件开发过程：
**逻辑视图**：以问题域的语汇组成的类和对象集合。
**进程视图**：可执行线程和进程作为活动类的建模，它是逻辑视图的一次执行实例，描绘了所设计的并发与同步结构。
**实现视图**：对组成基于系统的物理代码的文件和组件进行建模。
**部署视图**：把构件部署到一组物理的、可计算的节点上，表示软件到硬件的映射及分布结构。
**用例视图**：最基本的需求分析模型。

##### （6）OOA 需求建模
![模型图](/images/系统架构师/软件工程-需求工程需求分析模型图.png)

### 2.2.3 需求定义
![需求定义](/images/系统架构师/软件工程-需求工程需求定义.png)

### 2.2.4 需求验证
![需求验证](/images/系统架构师/软件工程-需求工程需求验证.png)

## 2.3 需求管理
### （1）定义需求基线


（2）需求跟踪

（3）变更控制—见第 6 章项目管理
带有风险的做法：无足够用户参与，忽略了用户分类，用户需求的不断增加，模棱两可的需求，不必要的特性，过于精简的 SRS，不准确的估算。


# 3-系统建模过