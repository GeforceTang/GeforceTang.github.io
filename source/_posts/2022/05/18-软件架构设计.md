---
title: 软件架构设计
date: 2022-10-22 15:15:15
categories: 软考笔记
tags: 软考高级
---

## 知识点提要

> - 软件架构的概念(⭐⭐⭐)
> - 软件架构风格(⭐⭐⭐⭐⭐ )
> - 架构描述语言ADL (⭐⭐⭐)
> - 特定领域软件架构(⭐⭐⭐)
> - 基于架构的软件开发(⭐⭐⭐⭐)
> - 软件质量属性(⭐⭐⭐⭐⭐ )
> - 软件架构评估(⭐⭐⭐⭐⭐)
> - 软件产品线(⭐⭐⭐)
> - 构件与中间件技术(⭐⭐⭐⭐)
> - Web架构设计 (⭐⭐⭐⭐⭐)

## 软件架构

### 概念

> 软件架构（即软件体系结构） = 架构设计处于需求分析和软件设计的中间，为了解决需求分析和软件设计之间的鸿沟。
>
> 架构设计就是需求分配，即将满足需求的职责分配到组件上。

- 软件架构风格是描述某一特定应用领域中系统组织方式的惯用模式。架构风格定义一个系统家族，即一个体系结构定义一个词汇表和组约束。词汇表中包含些构件和连接件类型，而这组约束指出系统是如何将这些构件和连接件组合起来的。
- 软件架构为软件系统提供了一个结构、行为和属性的高级抽象，由构成系统的元素的描述、这些元素的相互作用、指导元素集成的模式以及这些模式的约束组成。
- 软件架构是项目干系人进行交流的手段，明确了对系统实现的约束条件，决定了开发和维护组织的组织结构，制约着系统的质量属性。
- 软件架构使推理和控制的更改更加简单，有助于循序渐进的原型设计，可以作为培训的基础。
- 软件架构是可传递和可复用的模型，通过研究软件架构可能预测软件的质量。

#### 架构建模

结构模型：以架构的构件、连接件和其他概念来刻画结构

框架模型：不太侧重描述结构的细节而更侧重于整体的结构

动态模型：系统的"大颗粒”的行为性质

过程模型：构建系统的步骤和过程

功能模型：由一组功能构件按层次组成，下层向上层提供服务

#### 4+1视图

![image-20221022153744434](https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/image-20221022153744434.png)



## 架构风格

架构设计的一个核心问题是能否达到架构级的软件复用，架构风格反映了领域中众多系统所共有的结构和语义特性，并指导如何将各个构件有效地组织成一个完整的系统。

架构风格定义了用于描述系统的术语表和一组指导构建系统的规则。

| 五大架构风格  | 子风格                            |
| ------------- | --------------------------------- |
| 数据流风格    | 批处理、管道过滤器                |
| 调用/返回风格 | 主程序/子程序、面向对象、层次结构 |
| 独立构件风格  | 进程通信、事件驱动系统(隐式调用)  |
| 虚拟机风格    | 解释器、规则系统                  |
| 仓库风格      | 数据库系统、黑板系统、超文本系统  |

### 数据流风格

对数据进行处理，有一个相对固定的处理流程。**早期编译器就是采用的这种架构。要一步一步处理的，均可考虑采用此架构风格。**

- 批处理序列：构件为一系列固定顺序的计算单元，构件之间只通过数据传递交互。每个处理步骤是一个独立的程序，每一步必须在其前一步结束后才能开始，**数据必须是完整的,以整体的方式传递。**

- 管道-过滤器：每个构件都有一-组输入和输出，构件读输入的数据流，经过内部处理，然后产生输出数据流。这个过程通常是通过对输入数据流的变换或计算来完成的,包括通过计算和增加信息以丰富数据、通过浓缩和删除以精简数据、通过改变记录方式以转化数据和递增地转化数据等。这里的构件称为过滤器，连接件就是数据流传输的管道，将一个过滤器的输出传到另一个过滤器的输入。

### 调用/返回风格

支持基于抽象层的设计，将一个复杂问题分解成多个子实现。

- 主程序/子程序：单线程控制，把问题划分为若千个处理步骤,构件即为主程序和子程序，子程序通常可合成为模块。过程调用作为交互机制，即充当连接件的角色。调用关系具有层次性，其语义逻辑表现为主程序的正确性取决于它调用的子程序的正确性
- 面向对象：构件是对象，对象是抽象数据类型的实例。在抽象数据类型中，数据的表示和它们的相应操作被封装起来，对象的行为体现在其接受和请求的动作。连接件即是对象间交互的方式，对象是通过函数和过程的调用来交互的
- 层次结构：构件组织成一个层次结构，连接件通过决定层间如何交互的协议来定义。每层为上一层提供服务，使用下一层的服务，只能见到与自己邻接的层。通过层次结构，可以将大的问题分解为若干个渐进的小问题逐步解决，可以隐藏问题的复杂度。修改某一层，最多影响其相邻的两层(通常只能影响上层)

### 独立构件风格

封装一个构件的同时保证了构件的独立性，构件和构件之间是解耦合的。

- 进程通信：构件是独立的过程，连接件是消息传递。构件通常是命名过程，消息传递的方式可以是点对点、异步或同步方式，以及远程过程(方法)调用等。
- 事件驱动系统(隐式调用)：构件不直接调用一个过程，而是触发或广播个或多个事件。构件中的过程在一个或多个事件中注册，当某个事件被触发时，系统自动调用在这个事件中注册的所有过程。一个事件的触发就导致了另一个模块中的过程调用。这种风格中的构件是匿名的过程，它们之间交互的连接件往往是以过程之间的隐式调用来实现的。主要优点是为软件复用提供了强大的支持，为构件的维护和演化带来了方便；其缺点是构件放弃了对系统计算的控制。

### 虚拟机风格

- 解释器：解释器通常包括一个完成解释T作的解释引擎、一个包含将被解释的代码的存储区、一个记录解释引擎当前工作状态的数据结构，以及一个记录源代码被解释执行的进度的数据结构。具有解释器风格的软件中含有一个虚拟机，可以仿真硬件的执行过程和一些关键应用， 其缺点是执行效率比较低。
- 基于规则的系统：基于规则的系统包括规则集、规则解释器、规则/数据选择器和工作内存，一般用在人工智能领域和DSS中。

### 仓库风格

仓库风格中构件分两种: 一种是中央数据结构，保存系统的当前状态;另一种是独立构件，对中央数据存储进行操作。现代集成编译环境一般采用这种架构风格。

- 数据库系统：数据存储的职能。（黑板具有数据共享、传递、触发的职能）
- 黑板系统：包括知识源、黑板和控制三部分。知识源包括若干独立计算的不同单元，提供解决问题的知识。知识源响应黑板的变化，也只修改黑板；黑板是一个全局数据库，包含问题域解空间的全部状态，是知识源相互作用的唯媒介；知识源响应是通过黑板状态的变化来控制的。黑板系统通常应用在对于解决问题没有确定性算法的软件中(信号处理、问题规划和编译器优化等) 
- 超文本系统：构件以网状链接方式相互连接，用户可以在构件之间进行按照人类的联想思维方式任意跳转到相关构件。超文本是一种非线性的网状信息组织方法，它以结点为基本单位，链作为结点之间的联想式关联。超文本系统通常应用在互联网领域。

### 过程控制

当软件被用来操作一个物理系统时，软件与硬件之间可以粗略地表示为个反馈循环，这个反馈循环通过接受一定的输入，确定系列的输出,最终使环境达到一个新的状态。

适合于嵌入式系统，涉及连续的动作与状态。

![image-20221022200855483](https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/image-20221022200855483.png)

### C2风格

一种并行构件网络，C2架构的基本规则:

- 构件和连接件都有个顶部和一个底部。
- 构件的顶部要连接到连接件的底部，构件的底部要连接到连接件的顶部，构件之间不允许直连。
- 一个连接件可以和任意数目的其它构件和连接件连接。
- 当两个连接件进行直接连接时，必须由其中一个的底部到另个的顶部。

![image-20221022201053390](https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/image-20221022201053390.png)

1. 

### 层次架构风格

#### 两层C/S架构

开发成本较高、客户端程序设计复杂、信息内容和形式单一、用户界面风格不一、软件移植困难、软件维护和升级困难、新技术不能轻易应用

![image-20221023104139836](https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/image-20221023104139836.png)

#### 三层C/S架构

![image-20221023104306493](https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/image-20221023104306493.png)

#### 三层B/S架构

- B/S架构缺乏对动态页面的支持能力，没有集成有效的数据库处理功能
- B/S架构的安全性难以控制
- 采用B/S架构的应用系统,在数据查询等响应速度上，要远远低于C/S架构
- B/S架构的数据提交一般以页面为单位，数据的动态交互性不强，不利于OLTP应用

#### MVC架构

- Model(模型)：是应用程序中用于处理应用程序数据逻辑的部分。通常模型对象负责在数据库中存取数据。比如JSP。
- View(视图)：是应用程序中处理数据显示的部分。通常视图是依据模型数据创建的。比如Servlet。
- Controller(控制器)：是应用程序中处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。比如EJB EntityBean SessionBean

MVC分为主动型、被动型以及MVVM，被动型是减少View和Model的交互，而MVVM通过ViewModel彻底解决View和Model的耦合。

#### 富互联网应用（RIA）

应用了一些列的新技术，比如Ajax、H5等。

- RIA结合了C/S架构反应速度快、交互性强的优点，以及B/S架构传播范围广及容易传播的特性
- RIA简化并改进了B/S架构的用户交互
- 数据能够被缓存在客户端，从而可以实现一个比基于HTM的响应速度更快且数据往返于服务器的次数更少的用户界面

### 基于服务的架构（SOA）

服务是一种为了满足某项业务需求的操作、规则等的逻辑组合，它包含一系列有序活动的交互，为实现用户目标提供支持。

![image-20220926204108218](https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/image-20220926204108218.png)

#### 服务的特性

- 服务构件粗粒度，传统构件细粒度居多
- 服务构件的接口是标准的，主要是WSDL接口，传统构件常以具体API形式出现
- 服务构件的实现与语言无关，传统构件绑定某种特定语言
- 服务构件可以通过构件容器提供QoS的服务，传统构件完全由程序代码直接控制

<img src="https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/image-20220926204310806.png" alt="image-20220926204310806" style="zoom: 50%;" />

#### 服务实现方式

WSDL就是WebService接口对应的WSDL文件，该文件通过xml格式说明如何调用，以看作WebService的接口文档(使用说明书)。

- 服务注册：应用开发者(服务提供者)向注册表公布服务的功能
- 服务位置：服务使用者(服务应用开发者)，帮助他们查询注册服务，寻找符合自身要求的服务
- 服务绑定：服务使用者利用检索到的服务接来编写代码，所编写的代码将与注册的服务绑定、调用注册的服务,以及与它们实现互动

| 实现方式                                                     | 架构图                                                       | 层次结构                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 发现服务：UDDI、DISCO<br />描述服务：WSDL、XML Schema<br />消息格式层：SOAP、REST<br />编码格式层：XML (DOM， SAX) <br />传输协议层：HTTP、TCP/IP 、SMTP等 | <img src="https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/image-20220926204606877.png" alt="image-20220926204606877" style="zoom: 70%;" /> | - 底层传输层<br/>- 服务通信协议层<br/>- 服务描述层<br/>- 服务层<br/>- 业务流程层<br/>- 服务注册层 |

##### SOAP

> Simple Object Access Protocol。

SOAP是一种网络通信协议（HTTP+XML），用于网络上、不同平台、不同语言的应用程序间的通讯。简单对象访问协议，简单的说就是用于访问网络服务的协议；它是基于XML的简易协议，可使应用程序在HTTP之上进行信息交换。

##### REST

- HTTP + XML进行基于Web通信的技术
- 简单性，缺少严格配置文件
- 只支持几个操作(POST、GET、PUT、 DELETE)
- 强调信息本身，称为资源
  - 网络上的所有事物都被抽象为资源
  - 每个资源对应一个唯一的资源标识
  - 通过通用的连接器接口对资源进行操作
  - 对资源的各种操作不会改变资源标识
  - 所有的操作都是无状态的

#### ESB

企业服务总线（Enterprise Services Bus）

- 提供位置透明性的消息路由和寻址服务
- 提供服务注册和命名的管理功能
- 支持多种的消息传递范型
- 支持多种可以广泛使用的传输协议
- 支持多种数据格式及其相互转换
- 提供日志和监控功能

<img src="https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/image-20220926204753940.png" alt="image-20220926204753940" style="zoom:110%;" />

### 微服务

微服务顾名思义，就是很小的服务，所以它属于面向服务架构的一种。

微服务架构是一种架构模式，它提倡将单一应用程序划分成一组小的服务，服务之间互相协调、互相配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务与服务间采用轻量级的通信机制互相沟通(通常是基于HTTP协议的RESTful API)。每个服务都围绕着具体业务进行构建，并且能够被独立的部署到生产环境、类生产环境等。另外，应当尽量避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建。

#### 特点

- 小，职责单一，专注于做一件事情
- 轻量级的通信机制
- 松耦合、独立部署

<img src="https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/image-20220926214018187.png" alt="image-20220926214018187" style="zoom:60%;" />

#### 优势

1. 不同于单一应用的紧耦合，所有功能都在一个进程中；微服务是松耦合，功能在不同微服务的进程中。
2. 技术异构性：可以用不同的语言，不同的数据库。
3. 弹性：灵活性强，针对不同的场景压力能给出不同的应对策略。
4. 扩展：不再需要基于整个系统扩展，可基于独立服务，按需扩展。
5. 简化部署：依托于自动化体系（DevOps）简化人工成本。
6. 与组织结构相匹配
7. 可组合性
8. 对可替代性的优化

#### 面临的挑战

1. 分布式系统的复杂度：事务一致性等各种问题。
2. 运维成本：服务和服务之间的问题定位等难度。
3. 部署自动化：需要完善的流程体系。
4. DevOps与组织结构
5. 服务器依赖测试
6. 服务间依赖管理

#### 对比SOA

特性上的差异：

| 微服务特性                   | SOA特性                                     |
| ---------------------------- | ------------------------------------------- |
| 能拆分的就拆分               | 是整体的，服务能放一起的都放一起            |
| 纵向业务划分                 | 是水平分多层                                |
| 由单一组织负责               | 按层级划分不同部门的组织负责                |
| 细粒度                       | 粗粒度                                      |
| 两句话可以解释明白           | 几百字只相当于SOA的目录                     |
| 独立的子公司                 | 类似大公司里面划分了一些业务单元(BU)        |
| 组件小                       | 存在较复杂的组件                            |
| 业务逻辑存在于每一个服务中   | 业务逻辑横跨多个业务领域                    |
| 使用轻量级的通信方式，如HTTP | 企业服务产总线(ESB)充当了服务之间通信的角色 |

实现上的差异：

| 微服务架构实现                   | SOA实现                          |
| -------------------------------- | -------------------------------- |
| 团队级，自底向上开展实施         | 企业级，自顶向下开展实施         |
| 一个系统被拆分成多个服务，粒度细 | 服务由多个子系统组成，粒度大     |
| 无集中式总线，松散的服务架构     | 企业服务总线，集中式的服务架构   |
| 集成方式简单(HTTP/REST/JSON)     | 集成方式复杂(ESB/WS/SOAP)        |
| 服务能独立部署                   | 单块架构系统，相互依赖，部署复杂 |

### 模型驱动架构

> 属于形式化开发方法，通过定义自动形成代码，有点类似于现在的低代码平台。

模型驱动架构（Model Driven Architecture，MDA），起源于分离系统规约和平台实现的思想，主要目标：Portability (可移植性)，interoperability (互通性) ，Reusability (可重用性)。

- Model：客观事务的抽象表示
- Architecture：构成系统的部件、连接件及其约束的规约
- Model-Driven：使用模型完成软件的分析、设计、构建、部署、维护等各开发活动

MDA的3种核心模型:

- 平台独立模型(PIM)：具有高抽象层次、独立于任何实现技术的模型。
- 平台相关模型(PSM)：为某种特定实现技术量身定做，让你用这种技术中可用的实现构造来描述系统的模型。PIM会被变换成一个或多个PSM。
- 代码Code：用源代码对系统的描述(规约)。每个PSM都将被变换成代码。

<img src="https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/image-20220926220139845.png" alt="image-20220926220139845" style="zoom:80%;" />

## 架构描述语言（ADL）

ADL是这样一种形式化语言，它在底层语义模型的支持下，为软件系统的概念体系结构建模提供了具体语法和概念框架。基于底层语义的工具为体系结构的表示、分析、演化、细化、设计过程等提供支持。ADL的三个基本元素：

- 构件：计算或数据存储单元；
- 连接件：用于构件之间交互建模的体系结构构造块及其支配这些交互的规则；
- 架构配置：描述体系结构的构件与连接件的连接图。

### 主要的架构描述语言

- Aesop：支持体系结构风格的应用；
- MetaH：为设计者提供了关于实时电子控制软件系统的设计指导；
- C2：支持基于消息传递风格的用户界面系统的描述；
- Rapide：支持体系结构设计的模拟并提供了分析模拟结果的工具；
- SADL：提供了关于体系结构加细的形式化基础；
- Unicon：支持异构的构件和连接类型并提供了关于体系结构的高层编译器；
- Wright：支持体系结构构件之间交互的说明和分析。

## 领域软件架构（DSSA）

特定领域软件架构是指在某个业务领域下的程序功能开发，实际就是所在公司的业务范畴。而同一个领域下很多概念是相同的，可以提炼完成互用。

通过以架构为导向，分析行业的共性，做行业共性的架构设计以及完成一些业务提炼，以便于为后面大量的应用来做铺垫。

### 基本活动

领域分析（建立领域模型） -> 领域设计（获得DSSA） -> 领域实现（开发和组织可复用信息），这是一个重复的过程，逐步求精。

### 领域分析阶段

1、领域专家：有经验的用户、从事该领域中系统的需求分析、设计、实现以及项目管理的有经验的软件T程师等。领域专家的主要任务包括提供关于领域中系统的需求规约和实现的知识。

2、领域分析人员：领域分析人员应由具有知识工程背景的有经验的系统分析员来担任。

3、领域设计人员：领域设计人员应由有经验的软件设计人员来担任。

4、领域实现人员：领域实现人员应由有经验的程序设计人员来担任。

![image-20221023183117478](https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/image-20221023183117478.png)

### 建立过程

![image-20221023183459351](https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/image-20221023183459351.png)

### 三层次模型

领域开发环境：由**领域架构师**参与，负责参考结构、参考需求、架构、领域模型、开发工具。（类始于产品，负责基础的业务实现）

领域特定应用开发环境：应用工程师参与，对架构设计做实现。（类始于项目，对客户需求在产品的基础上做特殊的定制化改造）

应用执行环境：由操作员参与。（集成开发岗，对系统完成对应的配置化集成）



## 基于构架开发（ABSD）

ABSD方法是架构驱动，即强调由业务、质量和功能需求的组合驱动架构设计。ABSD能很好的支持软件重用。

### 基本概念

- 使用ABSD方法，设计活动可以从项目总体功能框架明确就开始，这意味着需求获取和分析还没有完成(甚至远远没有完成)，就开始了软件设计。
- ABSD方法有三个基础。第一个基础是功能的分解。在功能分解中，ABSD方法使用已有的基于模块的内聚和耦合技术；第二个基础是通过选择架构风格来实现质量和业务需求；第三个基础是软件模板的使用。软件模板利用了一些软件系统的结构。
- ABSD方法是递归的，且迭代的每一个步骤都是清晰地定义的。因此，不管设计是否完成，架构总是清晰的，这有助于降低架构设计的随意性。
- 视角与视图：从不同的视角来检查，所以会有不同的视图。
- 用例用来捕获功能需求、特定场景来捕获质量需求。

### 开发过程

架构文档化过程的主要输出结果是架构规格说明和测试架构需求的质量设计说明书这两个文档。文档的完整性和质量是软件架构成功的关键因素。

关于文档的三大注意事项：

- 文档要从使用者的角度进行编写
- 必须分发给所有与系统有关的开发人员
- 且必须保证开发者手上的文档是最新的

架构复审的目的是标识潜在的风险，及早发现架构设计中的缺陷和错误。

架构需求（需求分析） -> 架构设计 -> 架构文档化 -> 架构复审（重复0~N，退回到架构设计） -> 架构实现 -> 架构演化。 



## 软件架构评估

风险点：系统架构风险是指架构设计中潜在的、存在问题的架构决策所带来的隐患。

敏感点：是指为了实现某种特定的质量属性，一个或多个构件所具有的特性。

权衡点：是影响多个质量属性的特性，是多个质量属性的敏感点。

![image-20221023191741705](https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/image-20221023191741705.png)

### 评估方式

- 基于调查问卷(检查表)的方式
- 基于度量的方式
- 基于场景的方式

![image-20221023192009434](https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/image-20221023192009434.png)

## 练习题

### 架构风格

1. Java程序可以做到"一次编写，到处运行”，从架构风格上看符合( 虚拟机 )风格的特点。
2. 在网络通信中，进行包的解析, 一般先进行包头的分离，然后进行报文解析及后续处理，根据这一特点，选用( 数据流 )风格最合适。
3. 某公司欲开发一个基于图形用户界面的集成调试器。该调试器的编辑器和变量监视器可以设置调试断点。当调试器在断点处暂停运行时，编辑程序可以自动卷屏到断点，变量监视器刷新变量数值。针对这样的功能描述，采用( 隐式调用 ) 的架构风格最为合适。
4. 某游戏公司欲开发一个大型多人即时战略游戏,游戏设计的目标之一是能够支持玩家自行创建战役地图,定义游戏对象的行为和之间的关系。针对该目标，公司应该采用( 解释器 )架构风格最为合适。( 四选一：管道-过滤器、隐式调用、主程序-子程序、解释器)
5. 某公司承接了一个开发家用空调自动调温器的任务，调温器测量外部空气温度，根据设定的期望温度控制空调的开关。根据该需求，公司应采用( 过程控制 ) 架构风格最为合适。(四选一：解释器、过程控制、分层、管道-过滤器)
6. 某公司欲开发一个语音识别系统，语音识别的主要过程包括分割原始语音信号、识别音素、产生候选词、判定语法片断、提供语义解释等。每个过程都需要进行基于先验知识的条件判断并进行相应的识别动作。针对该系统的特点，采用( 黑板 ) 架构风格最为合适。(四选一：解释器、面向对象、黑板、隐式调用)
7. 某公司欲开发一个漫步者机器人，用来完成火星探测任务。机器人的控制者首先定义探测任务和任务之间的时序依赖性，机器人接受任务后，需要根据自身状态和外界环境进行动态调整，最终自动完成任务。针对这些需求，该机器人应该采用( 隐式调用 )架构风格最为合适。( 四选一：解释器、主程序-子程序、隐式调用、管道-过滤器)
8. Windows操作系统在图形用户界面处理方面采用的核心架构风格是( 事件驱动 ) 风格。
9. "编译器”是一种非常重要的基础软件，其核心功能是对源代码形态的单个或一组源程序依次进行预处理、词法分析、语法分析、语义分析、代码生成、代码优化等处理,最终生成目标机器的可执行代码。考虑以下与编译器相关的软件架构设计场景：传统的编译器设计中，上述处理过程都以独立功能模块的形式存在，程序源代码作为一个整体，依次在不同模块中进行传递，最终完成编译过程。针对这种设计思路，传统的编译器采用( B )架构风格比较合适。
   随着编译、链接、调试、执行等开发过程的一体化趋势发展，集成开发环境(IDE)随之出现。IDE集成了编译器、连接器、调试器等多种工具，支持代码的增量修改与处理，能够实现不同工具之间的信息交互，覆盖整个软件开发生命周期。针对这种需求，IDE采用( D )架构风格比较合适。IDE强调交互式编程，用户在修改程序代码后，会同时触发语法高亮显示、语法错误提示、程序结构更新等多种功能的调用与结果呈现，针对这种需求，通常采用( A )架构风格比较合适。
   某公司已经开发了一款针对某种嵌入式操作系统 专用编程语言的IDE，随着一种新的嵌入式操作系统上市并迅速占领市场，公司决定对IDE进行适应性改造，支持采用现有编程语言进行编程，生成符合新操作系统要求的运行代码，并能够在现有操作系统上模拟出新操作系统的运行环境，以支持代码调试工作。针对上述要求，为了使IDE能够生成符合新操作系统要求的运行代码，采用基于( B )的架构设计策略比较合适；为了模拟新操作系统的运行环境，通常采用( D )架构风格比较合适。
   (1)A.管道过滤器	B.顺序批处理	C.过程控制	D.独立进程
   (2) A.规则引擎	B.解释器	C.数据共享	D.黑板
   (3) A.隐式调用	B.显式调用	C.主程序子程序	D.层次结构
   (4) A.代理	B.适配	C.包装	D.模拟
   (5) A.隐式调用	B.仓库结构	C.基于规则	D.虚拟机
