---
title: 软件工程
date: 2022-09-24 21:56:11
categories: 软考笔记
tags: 软考高级
---

## 知识点提要
> - 信息系统生命周期(⭐⭐)
> - 软件开发方法(⭐⭐⭐)
> - 软件开发模型(⭐⭐⭐⭐)
> - UML(⭐⭐⭐⭐⭐)
> - 逆向工程(⭐)

## 信息系统生命周期

<img src="https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/image-20221008221136956.png" alt="image-20221008221136956" style="zoom:80%;" />

| 阶段                         | 过程                                                         | 产出物                                                       |
| ---------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 系统规划                     | 初步调查、分析系统目标、子系统组成、拟实施方案、可行性研究、制定系统建设方案 | 系统设计任务书(系统建设方案、实施计划)                       |
| **系统分析**<br />（做什么） | 业务流程分析、数据与数据流程分析、软件需求分析、网络需求分析 | 系统需求规格说明书、软件需求规格说明书、确认测试计划、系统测试计划、初步的用户手册 |
| **系统设计**<br />（怎么做） | 软件架构设计、软件概要设计、详细设计、网络设计               | 架构设计文档、概要设计说明书、详细设计说明书、程序规格说明书、概要测试计划、详细测试计划、各类设计图 |
| 系统实施                     | 软件编码、软件单元/集成/系统测试、综合布线                   | 源码、单元测试、集成测试报告、操作手册                       |
| 系统验收                     | 确认测试、试运行                                             | 确认测试报告，项目验收报告                                   |

## 软件开发方法

> 软件开发的方法学，通过制定的原则以期能够提高软件的质量、降低软件的成本。

结构化法：自顶向下，逐步分解求精；严格分阶段，阶段产出标准化；应变能力差

面向对象方法：自底向上；阶段界限不明；更好应变、更好复用；符合人们的思维习惯

面向服务的方法：粗粒度、松耦合；标准化和构件化；抽象级别（操作[低] -> 服务[中] ->业务流程[高]）

原型法：对于业务需求不明确时，通过原型进行引导。

- 按功能分：水平原型(界面)、垂直原型(复杂算法)；
- 按最终结果分：抛弃式原型、演化式原型

其他开发方法：

- 形式化方法：净室软件工程[受控污染级别的环境]；数学模型化；所有东西均可证明/验证，而不是测试。
- 统一过程方法[UP]
- 敏捷方法
- 基于架构的开发方法[ABSD]

## 软件开发模型

### 原型系列

<img src="https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/image-20220924220837937.png" alt="image-20220924220837937" style="zoom:80%;" />

### 瀑布模型

SDLC

<img src="https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/image-20220924220948393.png" alt="image-20220924220948393" style="zoom: 70%;" />

### V模型

测试贯穿于始终

![image-20220924221403592](https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/image-20220924221403592.png)

### 增量和迭代

<img src="https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/image-20220924221143019.png" alt="image-20220924221143019" style="zoom:80%;" />

### 螺旋模型

以原型为基础+瀑布模型，考虑了风险问题

![image-20220924221326855](https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/image-20220924221326855.png)

### 喷泉模型

早期著名的面向对象模型。迭代、无间隙。

### 构件组装模型

基于构件的开发方法（CBSD），速度快、可靠性高。

<img src="https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/image-20220924221537004.png" alt="image-20220924221537004" style="zoom:80%;" />

### 快速应用开发

SDLC是瀑布模型，而CBSD是基于构建的开发模型，2个组合起来就是RAD。

![image-20220924221745078](https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/image-20220924221745078.png)

### 统一过程

统一开发方法（UP、RUP），包括了初始、细化、构建和交付4个过程。

1. 初始阶段：确定项目范围和边界、识别系统的关键用例、展示系统的侯选架构、估计项目费用和时间、评估项目风险；
2. 细化阶段：分析系统问题领域、建立软件架构基础、淘汰最高风险元素；
3. 构建阶段：开发剩余的构件、构件组装与测试；
4. 交付阶段：进行测试、制作发布版本、用户文档定稿、确认新系统、培训调整产品。

<img src="https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/image-20220924222001655.png" alt="image-20220924222001655" style="zoom:80%;" />

### 敏捷方法

最初软件开发时没有方法论的指导，整个开发是无序、不可控的。后来出现了传统的软件开发方法，能预设性的做规划，以开发过程为本，整体分成了不同的阶段。

但是这个过程中依旧存在很多问题，后来又逐步演化出了敏捷方法，主要的理念：

- 适应性的
- 以人为本
- 增量迭代，小步快跑
- 适合小型项目

| 价值观                                                       | 基本原则                                                     | 过程实现规则                                                 |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 沟通：加强面对面沟通<br/>简单：不过度设计<br/>反馈：及时反馈<br/>勇气：接受变更的勇气 | 短平快的会议<br/>小型版本发布<br/>较少的文档<br/>合作为重<br/>客户直接参与<br/>自动化测试<br/>适应性计划调整<br/>结对编程<br/>测试驱动开发<br/>持续集成<br/>重构 | 简单设计<br/>测试驱动<br/>代码重构<br/>结对编程<br/>持续集成<br/>现场客户<br/>发行版本小型化<br/>系统隐喻<br/>代码集体所有制<br/>规划策略<br/>规范代码<br/>40小时工作机制 |

#### 敏捷开发方法

极限编程(XP)：一些对**费用控制严格的公司中的使用，非常有效**。

水晶方法：探索了**用最少纪律约束而仍能成功的方法**，从而在产出效率与易于运作.上达到一种平衡。

开放式源码：**程序开发人员在地域上分布很广（其他方法强调集中办公）**

SCRUM：**明确定义了的可重复的方法过程**。

功用驱动开发方法(FDD)：编程开发人员分成**首席程序员和“类”程序员**两类角色。

ASD方法：其核心是三个非线性的、重叠的开发阶段 **猜测、合作与学习**。

#### SCRUM

<img src="https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/image-20221008220635802.png" alt="image-20221008220635802" style="zoom:67%;" />

1. 具有一个需求池，在其中收集需要开发的需求功能
2. 制定计划，从需求池中提炼需求包，制定迭代计划
3. 通过每日例会了解整体计划进展

#### 极限编程

| 4大价值观                       | 5大原则                                                      | 12大最佳实践                                                 |
| ------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 沟通<br/>简单<br/>反馈<br/>勇气 | 快速反馈<br/>简单性假设<br/>逐步修改<br/>提倡更改<br/>优质工作 | 计划游戏<t/>结对编程<br/>小型发布<t/>集体代码所有制<br/>隐喻<t/>持续集成<br/>简单设计<t/>每周工作40小时<br/>测试先行<t/>现场客户<br/>重构<t/>编码标准 |

## UML

### 概述

![image-20220926151548203](https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/image-20220926151548203.png)



### 类图/对象图

类图(class diagram)：类图描述一组类、接口、协作和它们之间的关系。

对象图(object diagram)：对象图描述一组对象及它们之间的关系。对象图描述了在类图中所建立的事物实例的静态快照。

![image-20220926164204049](https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/image-20220926164204049.png)

- 类名，方法名，属性名
- 多重度：N对N，如0 ~ *、1 ~ 5
- 关系：类和类之间的关系

#### 类的关系

- 依赖关系：一个事物发生变化影响另一个事物。
- 泛化关系：特殊（子）/一般（父）关系。
- 关联关系：描述了一组链，链是对象之间的连接。
  - 聚合关系：整体与部分生命周期不同。
  - 组合关系：整体与部分生命周期相同。
- 实现关系：接口与类之间的关系。

![image-20220926165056326](https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/image-20220926165056326.png)

#### 例题

UML用关系把事物结合在一起，( D )描述一个事物发生变化会影响另一个事物的语义; ( C )描述特殊元素的对象可替换一般元素的对象。
A.聚合关系	B.关联关系	C.包含关系	D.依赖关系
A.实现关系	B.聚合关系	C.泛化关系	D.关联关系

### 用例图

- 用例图描述一组用例、参与者及它们之间的关系。
- 用户角度描述系统功能；
- 参与者是外部触发因素；(包括用户、组织、外部系统，时间)
- 用例是功能单元。

![image-20220926151916054](https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/image-20220926151916054.png)

#### 用例建模

1. 识别参与者(必须)
2. 合并需求获得用例(必须)
3. 细化用例描述(必须)
4. 调整用例模型(可选)：使用了3种关系。

#### 用例描述

![用例描述](https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/image-20220926152745096.png)

#### 用例关系

##### 包含关系

其中这个提取出来的公共用例称为抽象用例，而把原始用例称为基本用例或基础用例。当可以从两个或两个以上的用例中提取公共行为时，应该使用包含关系来表示它们。

![image-20220926153056321](https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/image-20220926153056321.png)

##### 扩展关系

（可选分流）如果一个用例明显地混合了两种或两种以上的不同场景，即根据情况可能发生多种分支，则可以将这个用例分为一个基本用例和一个或多个扩展用例，这样使描述可能更加清晰。

![image-20220926153119190](https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/image-20220926153119190.png)

##### 泛化关系

（父子关系）当多个用例共同拥有一种类似的结构和行为的时候，可以将它们的共性抽象成为父用例，其他的用例作为泛化关系中的子用例。在用例的泛化关系中，子用例是父用例的一种特殊形式，子用例继承了父用例所有的结构、行为和关系。

![image-20220926153139558](https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/image-20220926153139558.png)

#### 例题

##### 例题1

在某银行业务的用例模型中:“取款” 和“存款”两个用例中都需要执行查询余额的功能，将查询余额提取成独立的用例，那么“取款”和“存款”用例与“查询余额”用例之间的关
系属于( B )。
A.扩展关系	B.包含关系	C.依赖关系	D.继承关系

##### 例题2

采用UML分析用户需求时，用例UC1可以出现在用例UC2出现的任何位置，那么UC1和UC2之间的关系是( B )。
A. include	B. extend	C. generalize	D. call 

### 活动图

活动图(activity diagram)是一种特殊的状态图。活动图描述一个操作中要进行的各项活动的执行流程。同时，也常被用来描述一个用例的处理流程或者某种交互流程。

活动图将进程或其他计算结构展示为计算内部一步步的控制流和数据流。它强调对象间的控制流程。

![image-20220926150424589](https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/image-20220926150424589.png)

注意，活动图和流程图的区别：

1. 流程图是用在结构化需求分析中的，活动图则是UML用面向对象分析。
2. 活动图支持并行执行的业务流程，而流程图是线行的。

#### 泳道图

![image-20220926151339179](https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/image-20220926151339179.png)

### 顺序图

(sequence diagram,序列图)。顺序图是一种交互图(interaction diagram)， 它强调对象之间消息发送的顺序，同时显示对象之间的交互。

![image-20220926171259602](https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/image-20220926171259602.png)

### 通信图

协作图(communication diagram)，通信图也是一种交互图，它强调对象之间存在的消息收发关系，而不专门突出这些消息发送的时间顺序。

![image-20220926171625620](https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/image-20220926171625620.png)

### 状态图

(state diagram)是对类描述的补充。用于展现此类对象所具有的可能状态，以及某些事件发生时其状态转移情况。

![image-20220926171740261](https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/image-20220926171740261.png)

#### 例题

在订单处理的过程中，会员可以点击“取消订单”取消该订单。如果支付失败，该订单将被标记为挂起状态，可后续重新支付，如果挂起超时30分钟未支付，系统将自动取消该订单。订单支付成功后，系统判断订单类型:
(1)对于常规订单，标记为备货状态，订单信息发送到货运部，完成打包后交付快递发货;
(2)对于定制订单，会自动进入定制状态，定制完成后交付快递发货。会员在系统中点击“收货”按钮变为收货状态，结束整个订单的处理流程。

![image-20220926172027881](https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/image-20220926172027881.png)

S1：订单挂起、S2：订单备货、S3：订单定制、S4：订单发货、S5：订单收货

### 定时图

定时图也叫计时图，也是一种交互图，用于展示交互过程中的真实时间信息，具体描述对象状态变化的时间点以及维持特定状态的时间段。

![image-20220926173213293](https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/image-20220926173213293.png)

### 构件图/包图

构件图(component diagram)。构件图描述一个封装的类和它的接口、端口，以及由内嵌的构件和连接件构成的内部结构。构件图用于表示系统的静态设计实现视图。对于由小的部件构建大的系统来说，构件图是很重要的。构件图是类图的变体。

包图，包的图标像是一个带标签的文件夹，包的基本思想是把共同工作的元素放到一个文件夹中。例:多个类或构件组成了一个子系统，就可以将它们放到一个包中。

![image-20220926173429265](https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/image-20220926173429265.png)

### 部署图

(deployment diagram)。部署图描述对运行时的处理节点及在其中生存的构件的配置。部署图给出了架构的静态部署视图，通常一个节点包含一个或多个部署图。

![image-20220926173531064](https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/image-20220926173531064.png)

### 例题

#### 例题1

希赛公司欲开发一个在线交易系统。为了能够精确表达用户与系统的复杂交互过程，应该采用UML的( B )进行交互过程建模。
A.类图	B.顺序图	C.部署图	D.对象图

#### 例题2

( A )适用于描述复杂算法的执行流程。
A.活动图	B.状态图	C.类图	D.用例图

## 逆向工程

![image-20221008220846294](https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/image-20221008220846294.png)

## 净室工程

净室即无尘室、洁净室。也就是一个受控污染级别的环境。

使用盒结构规约 (或形式化方法)进行分析和设计建模，并且强调将正确性验证，而不是测试，作为发现和消除错误的主要机制。

使用统计的测试来获取认证被交付的软件的可靠性所必需的出错率信息。

## 课程例题

#### 例题1

软件方法学是以软件开发方法为研究对象的学科。其中，( D )是先对最高层次中的问题进行定义、设计、编程和测试，而将其中未解决的问题作为一个子任务放到下一层次中去解决。( A )是根据系统功能要求，从具体的器件、逻辑部件或者相似系统开始，通过对其进行相互连接、修改和扩大，构成所要求的系统。( B )是建立在严格数学基础上的软件开发方法。
A 面向对象开发方法	B 形式化开发方法	C 非形式化开发方法	D 自顶向下开发方法
A 自底向上开发方法	B 形式化开发方法	C 非形式化开发方法	D 原型开发方法
A 自底向上开发方法	B 形式化开发方法	C 非形式化开发方法	D 自顶向下开发方法

#### 例题2

( C )把整个软件开发流程分成多个阶段,每一个阶段都由目标设定、风险分析、开发和有效性验证以及评审构成。
A 原型模型
B 瀑布模型
C 螺旋模型
D V模型

#### 例题3

基于RUP的软件过程是一个迭代过程。一个开发周期包括初始、细化、构建和移交四个阶段，每次通过这四个阶段就会产生一代软件，其中建立完善的架构是( B )阶段的任务。采用迭代式开发，( A )。
A 初始	B 细化	C 构建	D 移交

A 在每一轮迭代中都要进行测试与集成
B 每一轮迭代的重点是对特定的用例进行部分实现
C 在后续迭代中强调用户的主动参与
D 通常以功能分解为基础

#### 例题4

下列关于敏捷方法的叙述中，错误的是( B )。
A 与传统方法相比，敏捷方法比较适合需求变化大或者开发前期对需求不是很清晰的项目
B 敏捷方法尤其适合于开发团队比较庞大的项目
C 敏捷方法的思想是适应性，而不是预设性
D 敏捷方法以原型开发思想为基础，采用迭代式增量开发

#### 例题5

( B )适用于程序开发人员在地域上分布很广的开发团队。 ( D )中,编程开发人员分成首席程序员和“类”程序员。
A 水晶系列(Crystal) 开发方法
B 开放式源码(Open source)开发方法
C SCRUM开发方法
D 功用驱动开发方法(FDD)

A 自适应软件开发(ASD)
B 极限编程(XP) 开发方法
C 开放统一过程开发方法(Open UP)
D 功用驱动开发方法(FDD)

#### 例题6

软件逆向工程就是分析已有的程序，寻求比源代码更高级的抽象表现形式。在逆向工程导出信息的四个抽象层次中，( B )包括反映程序各部分之间相互依赖关系的信息; ( C )包括反映程序段功能及程序段之间关系的信息。
A 实现级	B 结构级	C 功能级	D 领域级
A 实现级	B 结构级	C 功能级	D 领域级

## 综合练习

### （1）

用户文档主要描述所交付系统的功能和使用方法。下列文档中,（ ）属于用户文档。
A.需求说明书	B.系统设计文档	C.安装文档	D.系统测试计划

> 软件系统的文档可以分为用户文档和系统文档两类。用户文档主要描述系统功能和使用方法，并不关心这些功能是怎样实现的；系统文档描述系统设计、实现和测试等各方面的内容。
> 常见的用户文档包括：功能描述、安装文档、使用手册、参考手册、操作员指南

### （2）

用例(use case)用来描述系统对事件做出响应时所采取的行动。用例之间是具有相关性的。在一个”订单输入子系统”中，创建新订单和更新订单都需要核查用户帐号是否正确。用例“创建新订单”、“更新订单” 与用例"核查客户帐号”之间是（ ）关系。
A.包含(include)
B.扩展(extend)
C.分类(classification)
D.聚集(aggregation)

### （3）（4）

面向对象的设计模型包含以（ ）表示的软件体系结构图，以（ ）表示的用例实现图，完整精确的类图，针对复杂对象的状态图和用以描述流程化处理的活动图等。
A.部署图	B.包图	C.协同图	D.交互图
A.部署图	B.包图	C.协同图	D.交互图

### （5）

软件的横向重用是指重用不同应用领域中的软件元素。（ ）是一种典型的、原始的横向重用机制。
A.对象	B.构件	C.标准函数库	D.设计模式

### （6）

下列关于不同软件开发方法所使用的模型的描述中，正确的是（ ）。
A.在进行结构化分析时，必须使用数据流图和软件结构图这两种模型
B.采用面向对象开发方法时,可以使用状态图和活动图对系统的动态行为进行建模
C.实体联系图(E-R图)是在数据库逻辑结构设计时才开始创建的模型
D.UML的活动图与程序流程图的表达能力等价

### （7）

下列关于软件需求管理或需求开发的叙述中，正确的是（ ）。
A.所谓需求管理是指对需求开发的管理
B.需求管理包括：需求获取、需求分析、需求定义和需求验证
C.需求开发是将用户需求转化为应用系统成果的过程
D.在需求管理中，要求维持对用户原始需求和所有产品构件需求的双向跟踪

### (8)(9)

在面向对象设计中,用于描述目标软件与外部环境之间交互的类被称为（ ），它可以（ ）。
A.实体类	B.边界类	C.模型类	D.控制类
A.表示目标软件系统中具有持久意义的信息项及其操作
B.协调、控制其他类完成用例规定的功能或行为
C.实现目标软件系统与外部系统或外部设备之间的信息交流和互操作
D.分解任务并把子任务分派给适当的辅助类

### （10）

最少知识原则(也称为迪米特法则)是面向对象设计原则之一，指一个软件实体应当尽可能少地与其他实体发生相互作用。这样，当一个实体被修改时，就会尽可能少地影响其他的实体。下列叙述中，（ ）不符最少知识原则。
A.在类的划分上，应当尽量创建松耦合的类
B.在类的设计上，只要有可能，一个类型应当设计成不变类
C.在类的结构设计上，每个类都应当尽可能提高对其属性和方法的访问权限
D.在对其他类的引用上，一个对象对其他对象的引用应当降到最低

### （11）

快速迭代式的原型开发能够有效控制成本，（ ）是指在开发过程中逐步改进和细化原型直至产生出目标系统。
A.可视化原型开发	B.抛弃式原型开发	C.演化式原型开发	D.增量式原型开发

### （12）

确认测试主要用于验证软件的功能、性能和其他特性是否与用户需求一致。下述各种测试中，（ ）为确认测试。
A.负载测试和压力测试	B.α测试和β测试	C.随机测试和功能测试	D.可靠性测试和性能测试

### （13）

软件（  ）是指改正产生于系统开发阶段而在系统测试阶段尚未发现的错误。
A.完善性维护	B.适应性维护	C.正确性维护	D.预防性维护

### （14）

某软件公司正在设计个图像处理软件，该软件需要支持用户在图像处理过程中的撤销和重做等动作，为了实现该功能，采用（ ）最为合适。
A.单例模式	B.命令模式	C.访问者模式	D.适配器模式

### （15）

螺旋模型将整个软件 开发过程分为多个阶段，每个阶段都由目标设定、（ ）开发和有效性验证以及评审4个部分组成。
A.需求分析	B.风险分析	C.系统设计	D.架构设计

### （16）（17）

快速应用开发(Rapid Application Development,RAD)通过使用基于（ ）的开发方法获得快速开发。当（ ）时，最适合于采用RAD方法。
A.用例	B.数据结构	C.剧情	D.构件
A.一个新系统要采用很多新技术
B.新系统与现有系统有较高的互操作性
C.系统模块化程度较高
D.用户不能很好地参与到需求分析中

### （18）

以下关于软件开发方法的叙述，错误的是（ ）。
A.对于较为复杂的应用问题，适合采用形式化方法进行需求分析
B.形式化方法的优势在于能够精确地表述和研究应用问题及其软件实现
C.净室软件工程将正确性验证作为发现和排除错误的主要机制
D.净室软件工程强调统计质量控制技术，包括对客户软件使用预期的测试

### （19）

对于违反里氏替换原则的两个类A和B，可以采用的候选解决方案中，正确的是（ ）。
A.尽量将一些需要扩展的类或者存在变化的类设计为抽象类或者接口，并将其作为基类，在程序中尽量使用基类对象进行编程
B.创建一个新的抽象类C，作为两个具体类的超类，将A和B共同的行为移动到C中，从而解决A和B行为不完全致的问题
C.将B到A的继承关系改成组合关系
D.区分是"Is-a”还是"Has-a"。如果是Is-a可以使用继承关系，如果是Has-a应该改成组合或聚合关系

### （20）（21）（22）

某软件公司欲设计一款图像处理软件 ，帮助用户对拍摄的照片进行后期处理。在软件需求分析阶段，公司的系统分析师识别出了如下3个关键需求:
	图像处理软件需要记录用户在处理照片时所有动作，并能够支持用户动作的撤销与重做等行为。
	图像处理软件需要根据当前正在处理的照片的不同特征选择合适的处理操作，处理操作与照片特征之间具有较为复杂的逻辑关系。
	图像处理软件需要封装各种图像处理算法,用户能够根据需要灵活选择合适的处理算法；软件还要支持高级用户根据一定的规则添加自定义处理算法。
在系统设计阶段，公司的架构师决定采用设计模式满足上述关键需求中对系统灵活性与扩展性的要求。具体来说，为了支持灵活的撤销与重做等行为，采用（ ）最为合适；为了封装图像操作与照片特征之间的复杂逻辑关系，采用（ ）最为合适: 为了实现图像处理算法的灵活选择与替换，采用（ ）最为合适。
A.工厂模式	B.责任链模式	C.中介者模式	D.命令模式
A.状态模式	B.适配器模式	C.组合模式	D.单例模式
A.模板方法模式	B.访问者模式	C.策略模式	D.观察者模式

### （23）（24）

逆向工程导出的信息可以分为实现级、结构级、功能级和领域级四个抽象层次。程序的抽象语法树属于（ ）；反映程序分量之间相互依赖关系的信息属于（ ）。
A.实现级	B.结构级	C.功能级	D.领域级
A.实现级	B.结构级	C.功能级	D.领域级

> 实现级：包括程序的抽象语法树、符号表、过程的设计表示
> 结构级：包括反映程序分量之间相互依赖关系的信息，例如调用图、结构图、程序和数据结构
> 功能级：包括反映程序段功能及程序段之间关系的信息，例如数据和控制流模型
> 领域级：包括反映程序分量或程序诸实体与应用领域概念之间对应关系的信息，例如实体关系模型

### （25）（26）

某系统中的文本显示类(TextView)和图片显示类(PictureView)都继承了组件类(Component)，分别显示文本和图片内容，现需要构造带有滚动条或者带有黑色边框，或者既有滚动条又有黑色边框的文本显示控件和图片显示控件，但希望最多只增加3个类。那么采用设计模式（ ）可实现该需求，其优点是（ ）。
A.外观	B.单体	C.装饰	D.模板方法
A.比静态继承具有更大的灵活性
B.提高已有功能的重复使用性
C.可以将接口与实现相分离
D.为复杂系统提供了简单接口

### （27）

以下关于自顶向下开发方法的叙述中，正确的是（ ）。
A.自顶向下过程因为单元测试而比较耗费时间
B.自顶向下过程可以更快地发现系统性能方面的问题
C.相对于自底向上方法，自顶向下方法可以更快地得到系统的演示原型
D.在自顶向下的设计中，如发现了一个错误，通常是因为底层模块没有满足其规格说明(因为高层模块已经被测试过了)

### （28）

以下关于面向对象软件测试的叙述中，正确的是（ ）。
A.在测试一个类时，只要对该类的每个成员方法都进行充分的测试就完成了对该类充分的测试
B.存在多态的情况下，为了达到较高的测试充分性，应对所有可能的绑定都进行测试
C.假设类B是类A的子类，如果类A已经进行了充分的测试，那么在测试类B时不必测试任何类B继承自类A的成员方法
D.对于一棵继承树上的多个类，只有处于叶子节点的类需要测试

### （29）

系统建议方案中不应该包含的内容是（ ）。
A.问题陈述	B.项目范围	C.候选方案及其可行性分析	D.系统详细设计方案

### （30）

下列关于联合需求计划(Joint Requirement Planning, JRP)的叙述中，不正确的是（ ）。
A.在JRP实施之前,应制定详细的议程，并严格遵照议程进行
B.在讨论期间尽量避免使用专业术语
C.JRP是一种相对来说成本较高但十分有效的需求获取方法
D.JRP的主要目的是对需求进行分析和验证

### （31）（32）

在结构化分析方法中，用（ ）表示功能模型，用（ ）表示行为模型。
A.ER图	B.用例图	C.DFD	D.对象图
A.通信图	B.顺序图	C.活动图	D.状态转换图

### （33）

下列关于用户界面设计的叙述中，错误的是（ ）。
A.界面交互模型应经常进行修改
B.界面的视觉布局应该尽量与真实世界保持致
C.所有可视信息的组织需要按照统一的设计标准
D.确保用户界面操作和使用的一致性

### （34）

一组对象以定义良好但是复杂的方式进行通信，产生的相互依赖关系结构混乱且难以理解。采用（ ）模式，用一个特定对象来封装-系列的对象交互，从而使各对象不需要显式地相互引用，使其耦合松散，而且可以独立地改变它们之间的交互。
A.解释器(Interpreter)	B.策略(Strategy)	C.中介者(Mediator)	D.迭代器(Iterator)

### （35）（36）

在UML提供的系统视图中,（ ）是逻辑视图的一次执行实例，描述了并发与同步结构；（ ）是最基本的需求分析模型。
A.进程视图	B.实现视图	C.部署视图	D.用例视图
A.进程视图	B.实现视图	C.部署视图	D.用例视图

### （37）

下列关于软件调试与软件测试的叙述中，正确的是（ ）。
A.软件测试的目的是找出存在的错误，软件调试的目的是定位并修正错误
B.软件测试的结束过程不可预计，软件调试使用预先定义的过程
C.软件调试的过程可以实现设计
D.软件测试不能描述过程或持续时间

### （38）

用例(use case)用来描述系统对事件做出响应时所采取的行动。用例之间是具有相关性的。在一个会员管理系统中，会员注册时可以采用电话和邮件两种方式。用例“会员注册”和"电话注册”、“邮件注册”之间是（ ）关系。
A.包含(include)	B.扩展(extend)	C.泛化(generalize)	D.依赖(dependson)

### （39）（40）

某软件公司欲开发一个绘图软件，要求使用不同的绘图程序绘制不同的图形。在明确用户需求后，该公司的架构师决定采用Bridge模式实现该软件，并设计UML类图如下图所示。图中与
Bridge模式中的"Abstraction"角色相对应的类是（ ），与"Implementor"角色相对应的类是（ ）。
A.Shape	B.Drawing	C.Rectangle	D.V2Drawing
A.Shape	B.Drawing	C.Rectangle	D.V2Drawing

![image-20221021160337255](https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/image-20221021160337255.png)

### （41）（42）

RUP强调采用（ ）的方式来开发软件，这样做的好处是（ ）。
A.原型和螺旋	B.螺旋和增量	C.迭代和增量	D.快速和迭代
A.在软件开发的早期就可以对关键的，影响大的风险进行处理
B.可以避免需求的变更
C.能够非常快速地实现系统的所有需求
D.能够更好地控制软件的质量

### （43）

对于遗留系统的评价框架如下图所示，那么处于"高水平、低价值”区的遗留系统适合于采用的演化策略为（ ）。
A.淘汰	B.继承	C.改造	D.集成

### （44）（45）

（ ）的目的是检查模块之间，以及模块和已集成的软件之间的接口关系，并验证已集成的软件是否符合设计要求。其测试的技术依据是（ ）。
A.单元测试	B.集成测试	C.系统测试	D.回归测试
A.软件详细设计说明书	B.技术开发合同	C.软件概要设计文档	D.软件配置文档

> V模型，单元测试 -> 详细设计，集成测试 -> 概要设计。

### 答案

|  1~10   |  11~20  |  21~30  |  31~40  |  41~50  |
| :-----: | :-----: | :-----: | :-----: | :-----: |
| （1）C  | （11）C | （21）A | （31）C | （41）C |
| （2）A  | （12）B | （22）C | （32）D | （42）A |
| （3）B  | （13）C | （23）A | （33）A | （43）D |
| （4）D  | （14）B | （24）B | （34）C | （44）B |
| （5）C  | （15）B | （25）C | （35）A | （45）C |
| （6）B  | （16）D | （26）A | （36）D |         |
| （7）D  | （17）C | （27）C | （37）A |         |
| （8）B  | （18）A | （28）B | （38）C |         |
| （9）C  | （19）A | （29）C | （39）A |         |
| （10）D | （20）D | （30）D | （40）B |         |





