---
title: 系统设计
date: 2022-09-26 20:28:58
categories: 软考笔记
tags: 软考高级
---

## 知识点提要
> - 软件架构设计(⭐⭐⭐)
> - 人机界面设计(⭐⭐)
> - 结构化设计(⭐⭐⭐)
> - 面向对象设计(⭐⭐⭐⭐)

## 架构设计

> 软件架构 = 软件体系结构，架构设计就是需求分配，即将满足需求的职责分配到组件上。软件架构是为了解决需求分析和软件设计之间的鸿沟。

### 架构风格

架构风格反映了领域中众多系统所共有的结构和语义特性，并指导如何将各个构件有效地组织成一个完整的系统。

架构风格定义了用于描述系统的术语表和一组指导构建系统的规则。

| 五大架构风格  | 子风格                            |
| ------------- | --------------------------------- |
| 数据流风格    | 批处理、管道过滤器                |
| 调用/返回风格 | 主程序/子程序、面向对象、层次结构 |
| 独立构件风格  | 进程通信、事件驱动系统(隐式调用)  |
| 虚拟机风格    | 解释器、规则系统                  |
| 仓库风格      | 数据库系统、黑板系统、超文本系统  |

### 基于服务架构风格（SOA）

服务是一种为了满足某项业务需求的操作、规则等的逻辑组合，它包含一系列有序活动的交互，为实现用户目标提供支持。

![image-20220926204108218](https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/image-20220926204108218.png)

#### 服务的特性

- 服务构件粗粒度，传统构件细粒度居多
- 服务构件的接口是标准的，主要是WSDL接口，传统构件常以具体API形式出现
- 服务构件的实现与语言无关，传统构件绑定某种特定语言
- 服务构件可以通过构件容器提供QoS的服务，传统构件完全由程序代码直接控制

<img src="https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/image-20220926204310806.png" alt="image-20220926204310806" style="zoom: 100%;" />

#### 服务实现方式

发现服务：UDDI、DISCO

描述服务：WSDL、XML Schema

消息格式层：SOAP、REST

编码格式层：XML (DOM， SAX) 

传输协议层：HTTP、TCP/IP 、SMTP等

<table><tr>
<td width="70%">
<img src="https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/image-20220926204606877.png" alt="image-20220926204606877" style="zoom: 100%;" />
</td>
<td>
<li>底层传输层</li>
<li>服务通信协议层</li>
<li>服务描述层</li>
<li>服务层</li>
<li>业务流程层</li>
<li>服务注册层</li>
</td>
</tr></table>

WSDL就是WebService接口对应的WSDL文件，该文件通过xml格式说明如何调用，以看作WebService的接口文档(使用说明书)。

#### ESB

<table><tr>
<td width="70%">
<img src="https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/image-20220926204753940.png" alt="image-20220926204753940" style="zoom:110%;" />
</td>
<td>
    <li>提供位置透明性的消息路由和寻址服务</li>
    <li>提供服务注册和命名的管理功能</li>
    <li>支持多种的消息传递范型</li>
    <li>支持多种可以广泛使用的传输协议</li>
    <li>支持多种数据格式及其相互转换</li>
    <li>提供日志和监控功能</li>
</td>
</tr></table>



### 微服务

微服务顾名思义，就是很小的服务，所以它属于面向服务架构的一种。

微服务架构是一种架构模式，它提倡将单一应用程序划分成一组小的服务，服务之间互相协调、互相配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务与服务间采用轻量级的通信机制互相沟通(通常是基于HTTP协议的RESTful API)。每个服务都围绕着具体业务进行构建，并且能够被独立的部署到生产环境、类生产环境等。另外，应当尽量避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建。

#### 特点

- 小，职责单一，专注于做一件事情
- 轻量级的通信机制
- 松耦合、独立部署

<img src="https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/image-20220926214018187.png" alt="image-20220926214018187" style="zoom:60%;" />

#### 优势

1. 不同于单一应用的紧耦合，所有功能都在一个进程中；微服务是松耦合，功能在不同微服务的进程中。
2. 技术异构性：可以用不同的语言，不同的数据库。
3. 弹性：灵活性强，针对不同的场景压力能给出不同的应对策略。
4. 扩展：不再需要基于整个系统扩展，可基于独立服务，按需扩展。
5. 简化部署：依托于自动化体系（DevOps）简化人工成本。
6. 与组织结构相匹配
7. 可组合性
8. 对可替代性的优化

#### 面临的挑战

1. 分布式系统的复杂度：事务一致性等各种问题。
2. 运维成本：服务和服务之间的问题定位等难度。
3. 部署自动化：需要完善的流程体系。
4. DevOps与组织结构
5. 服务器依赖测试
6. 服务间依赖管理

#### 对比SOA

| 微服务特性                   | SOA特性                                     |
| ---------------------------- | ------------------------------------------- |
| 能拆分的就拆分               | 是整体的，服务能放一起的都放一起            |
| 纵向业务划分                 | 是水平分多层                                |
| 由单一组织负责               | 按层级划分不同部门的组织负责                |
| 细粒度                       | 粗粒度                                      |
| 两句话可以解释明白           | 几百字只相当于SOA的目录                     |
| 独立的子公司                 | 类似大公司里面划分了一些业务单元(BU)        |
| 组件小                       | 存在较复杂的组件                            |
| 业务逻辑存在于每一个服务中   | 业务逻辑横跨多个业务领域                    |
| 使用轻量级的通信方式，如HTTP | 企业服务产总线(ESB)充当了服务之间通信的角色 |

| 微服务架构实现                   | SOA实现                          |
| -------------------------------- | -------------------------------- |
| 团队级，自底向上开展实施         | 企业级，自顶向下开展实施         |
| 一个系统被拆分成多个服务，粒度细 | 服务由多个子系统组成，粒度大     |
| 无集中式总线，松散的服务架构     | 企业服务总线，集中式的服务架构   |
| 集成方式简单(HTTP/REST/JSON)     | 集成方式复杂(ESB/WS/SOAP)        |
| 服务能独立部署                   | 单块架构系统，相互依赖，部署复杂 |

## 软件设计

> 软件设计包括体系结构设计、接口设计、数据设计和过程设计。
>
> - 结构设计：定义软件系统各主要部件之间的关系。
> - 数据设计：将模型转换成数据结构的定义。好的数据设计将改善程序结构和模块划分，降低过程复杂性。
> - 接口设计(人机界面设计)：软件内部，软件和操作系统间以及软件和人之间如何通信。
> - 过程设计：系统结构部件转换成软件的过程描述。

### 人机界面设计

**黄金三法则：置于用户控制之下、减少用户的记忆负担、保持界面的一致性。**

1. 置于用户控制之下

- 以不强迫用户进入不必要的或不希望的动作的方式来定义交互方式
- 提供灵活的交互
- 允许用户交互可以被中断和撤销
- 当技能级别增加时可以使交互流水化并允许定制交互
- 使用户隔离内部技术细节
- 设计应允许用户和出现在屏幕上的对象直接交互

2. 减少用户的记忆负担

- 减少对短期记忆的要求
- 建立有意义的缺省
- 定义直觉性的捷径
- 界面的视觉布局应该基于真实世界的隐喻
- 以不断进展的方式揭示信息

3. 保持界面的一致性

- 允许用户将当前任务放入有意义的语境
- 在应用系列内保持一致性
- 如过去的交互模型已建立起了用户期望，除非有迫不得已的理由，不要改变它

### 结构化设计

> 概要设计（外部设计）：功能需求分配给软件模块，确定每个模块的功能和调用关系，形成模块结构图。
>
> 详细设计（内部设计）：为每个具体任务选择适当的技术手段和处理方法。

#### 结构化设计原则

- 模块独立(高内聚、低耦合)
- 保持模块的大小适中
- 多扇入，少扇出
- 深度和宽度均不宜过高

#### 模块的四个要素

1. 输入和输出。模块的输入来源和输出去向都是同一个调用者，即一个模块从调用者那儿取得输入，进行加工后再把输出返回调用者。
2. 处理功能。指模块把输入转换成输出所做的工作。
3. 内部数据。指仅供该模块本身引用的数据。
4. 程序代码。指用来实现模块功能的程序。

### 内聚和耦合

| 内聚度 | 内聚类型           | 描述                                         |
| :----: | ------------------ | -------------------------------------------- |
|   7    | 功能内聚           | 完成一个单一功能，各个部分协同工作，缺一不可 |
|   6    | 顺序内聚           | 处理元素相关，而且必须顺序执行               |
|   5    | 通信内聚           | 所有处理元素集中在一个数据结构的区域上       |
|   4    | 过程内聚           | 处理元素相关，而且必须按特定的次序执行       |
|   3    | 瞬时内聚(时间内聚) | 所包含的任务必须在同一时间间隔内执行         |
|   2    | 逻辑内聚           | 完成逻辑上相关的一组任务                     |
|   1    | 偶然内聚(巧合内聚) | 完成一组没有关系或松散关系的任务             |

| 耦合度 | 耦合类型   | 描述                                                         |
| :----: | ---------- | ------------------------------------------------------------ |
|   1    | 非直接耦合 | 两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的 |
|   2    | 数据耦合   | 一组模块借助参数表传递简单数据                               |
|   3    | 标记耦合   | 一组模块通过参数表传递记录信息(数据结构)                     |
|   4    | 控制耦合   | 模块之间传递的信息中包含用于控制模块内部逻辑的信息           |
|   5    | 外部耦合   | 一组模块都访问同一全局简单变量，而且不是通过参数表传递该全局变量的信息 |
|   6    | 公共耦合   | 多个模块都访问同一个公共数据环境                             |
|   7    | 内部耦合   | 一个模块直接访问另一个模块的内部数据; 一个模块不通过正常入口转到另一个模块的内部;两个模块有一部分程序代码重叠; 一个模块有多个入口 |

### 面向对象设计

#### 基本过程

<img src="https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/image-20220926222403376.png" alt="image-20220926222403376" style="zoom:80%;" />

#### 设计原则

- 单一职责原则：设计目的单一的类
- 开放-封闭原则：对扩展开放，对修改封闭
- 里氏替换原则(Liskov)：子类可以替换父类
- 依赖倒置原则：要依赖于抽象，而不是具体实现；针对接口编程，不要针对实现编程
- 接口隔离原则：使用多个专门的接口比使用单一的总接口要好
- 组合重用原则：要尽量使用组合，而不是继承关系达到重用目的
- 迪米特原则(Demeter，最少知识原则)：一个对象应当对其他对象有尽可能少的了解

### 设计模型

架构模式：软件设计中的高层决策，例如C/S结构就属于架构模式，架构模式反映了开发软件系统过程中所作的基本设计决策

设计模式：主要关注软件系统的设计，与具体的实现语言无关

惯用法：是最低层的模式，关注软件系统的设计与实现，实现时通过某种特定的程序设计语言来描述构件与构件之间的关系。每种编程语言都有它自己特定的模式，即语言的惯用法。例如引用-计数就是C++语言中的一种惯用法

#### 创建型

| 设计模式名称                     | 简要说明                                                     | 速记关键字     |
| -------------------------------- | ------------------------------------------------------------ | -------------- |
| 工厂方法模式（Factory Method）   | 定义一个创建对象的接口，但由子类决定需要实例化哪一个类。工方法使得子类实例化的过程推迟 | 动态生产对象   |
| 抽象工厂模式（Abstract Factory） | 提供一个接口，可以创建一系列相关或相互依赖的对象，而无需指定它们具体的类 | 生产成系列对象 |
| 构建器模式（Builder）            | 将一个复杂类的表示与其构造相分离，使得相同的构建过程能够得出不同的表示 | 复杂对象构造   |
| 原型模式（Prototype）            | 用原型实例指定创建对象的类型，并且通过拷贝这个原型来创建新的对象 | 克隆对象       |
| 单例模式（Singleton）            | 保证一个类只有一个实例，并提供个访问它的全局访问点           | 单实例         |

#### 结构性

| 设计模式名称          | 简要说明                                                     | 速记关键字   |
| --------------------- | ------------------------------------------------------------ | ------------ |
| 适配器模式（Adapter） | 将一个类的接口转换成用户希望得到的另一种接口。它使原本不相容的接口得以协同工作 | 转换接口     |
| 桥接模式（Bridge）    | 将类的抽象部分和它的实现部分分离开来，使它们可以独立地变化   | 继承树拆分   |
| 组合模式（Composite） | 将对象组合成树型结构以表示“整体部分”的层次结构，使得用户对单个对象和组合对象的使用具有一致性 | 树形目录结构 |
| 装饰模式（Decorator） | 动态地给一个对象添加一些额外的职责。它提供了用子类扩展功能的个灵活的替代，比派生一个子类更加灵活 | 动态附加职责 |
| 外观模式（Facade）    | 定义一个高层接口，为子系统中的一组接口提供一个致的外观，从而简化了该子系统的使用 | 对外统一接口 |
| 享元模式（Flyweight） | 提供支持大量细粒度对象共享的有效方法                         | 汉字编码     |
| 代理模式（Proxy）     | 为其他对象提供一种代理以控制这个对象的访问                   | 快捷方式     |

#### 行为型

| 设计模式名称                          | 简要说明                                                     | 速记关键宇       |
| ------------------------------------- | ------------------------------------------------------------ | ---------------- |
| 职责链模式（Chain of Responsibility） | 通过给多个对象处理请求的机会，减少请求的发送者与接收者之间的耦合。将接收对象链接起来，在链中传递请求，直到有一个对象处理这个请求 | 传递职责         |
| 命令模式（Command）                   | 将个请求封装为一个对象，从而可用不同的请求对客户进行参数化，将请求排队或记录请求日志，支持可撤销的操作 | 日志记录，可撤销 |
| 解释器模式（Interpreter）             | 给定一种语言，定义它的文法表示，并定义一个解释器该解释器用来根据文法表示来解释语言中的句子 | 虚拟机的机制     |
| 迭代器模式（Iterator）                | 提供一种方法来顾序访问一个聚合对象中的各个元素，而不需要暴露该对象的内部表示 | 数据集           |
| 中介者模式（Mediator）                | 用一个中介对象来封装一系列的对象交互。它使各对象不需要显式地相互调用，从而达到低耦合，还可以独立地改变对象间的交互 | 不直接引用       |
| 备忘录模式（Memento）                 | 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，从而可以在以后将该对象恢复到原先保存的状态 | 游戏存档         |
| 观察者模式（Observer）                | 定义对象间的一种一对多的依赖关系，当个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新 | 联动             |
| 状态模式（State）                     | 允许一个对象在其内部状态改变时改变它的行为                   | 状态变成类       |
| 策略模式（Strategy）                  | 定义一系列算法，把它们一个个封装起来，并且使它们之间可互相替换，从而让算法可以独立于使用它的用户而变化 | 多方案切换       |
| 模板方法模式（Template Method）       | 定义一个操作中的算法骨架，而将些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重新定义算法的某些特定步骤 | 框架             |
| 访问者模式（Visitor）                 | 表示个作用于某对象结构中的各元素的操作，使得在不改变各元素的类的前提下定义作用于这些元素的新操作 | 数据与操作分离   |

## 例题

#### 例题1

下列关于用户界面设计的叙述中，错误的是( A )。
A 界面交互模型应经常进行修改
B 界面的视觉布局应该尽量与真实世界保持一致
C 所有可视信息的组织需要按照统一的设计标准
D 确保用户界面操作和使用的一致性

#### 例题2

软件设计包括了四个既独立又相互联系的活动：高质量的( B )将改善程序结构和模块划分，降低过程复杂性; ( A )的主要目标是开发一个模块化的程序结构，并表示出模块间的控制关系; ( D )描述了软件与用户之间的交互关系。
A 程序设计	B 数据设计	C 算法设计	D 过程设计
A 软件结构设计	B 数据结构设计	C 数据流设计	D 分布式设计
A 数据架构设计	B 模块化设计	C 性能设计	D人 机界面设计

#### 例题3

最少知识原则(也称为迪米特原则) 是面向对象设计原则之一，指一个软件实体应当尽可能少地与其他实体发生相互作用。这样，当一个实体被修改时，就会尽可能少地影响其他的实体。下列叙述中，( C )不符最少知识原则。
A 在类的划分上，应当尽量创建松耦合的类
B 在类的设计上，只要有可能，一个类型应当设计成不变类
C 在类的结构设计上，每个类都应当尽可能提高对其属性和方法的访问权限
D 在对其他类的引用上，一个对象对其他对象的引用应当降到最低

#### 例题4

( A )的选择是开发一个软件系统时的基本设计决策;( B )是最低层的模式，关注软件系统的设计与实现，描述了如何实现构件及构件之间的关系。引用一计数是C++管理动态资源时常用的一种( B )。
A.架构模式	B.惯用法	C.设计模式	D.分析模式
A.架构模式	B.惯用法	C.设计模式	D.分析模式
A.架构模式	B.惯用法	C.设计模式	D.分析模式
