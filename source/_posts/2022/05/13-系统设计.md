---
title: 系统设计
date: 2022-09-26 20:28:58
categories: 软考笔记
tags: 系统分析
---

## 知识点提要
> - 软件架构设计(⭐⭐⭐)
> - 人机界面设计(⭐⭐)
> - 结构化设计(⭐⭐⭐)
> - 面向对象设计(⭐⭐⭐⭐)

## 架构设计

> 软件架构 = 软件体系结构，架构设计就是需求分配，即将满足需求的职责分配到组件上。软件架构是为了解决需求分析和软件设计之间的鸿沟。

### 架构风格

架构风格反映了领域中众多系统所共有的结构和语义特性，并指导如何将各个构件有效地组织成一个完整的系统。

架构风格定义了用于描述系统的术语表和一组指导构建系统的规则。

| 五大架构风格  | 子风格                            |
| ------------- | --------------------------------- |
| 数据流风格    | 批处理、管道过滤器                |
| 调用/返回风格 | 主程序/子程序、面向对象、层次结构 |
| 独立构件风格  | 进程通信、事件驱动系统(隐式调用)  |
| 虚拟机风格    | 解释器、规则系统                  |
| 仓库风格      | 数据库系统、黑板系统、超文本系统  |

### 基于服务架构风格（SOA）

服务是一种为了满足某项业务需求的操作、规则等的逻辑组合，它包含一系列有序活动的交互，为实现用户目标提供支持。

![image-20220926204108218](https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/image-20220926204108218.png)

#### 服务的特性

- 服务构件粗粒度，传统构件细粒度居多
- 服务构件的接口是标准的，主要是WSDL接口，传统构件常以具体API形式出现
- 服务构件的实现与语言无关，传统构件绑定某种特定语言
- 服务构件可以通过构件容器提供QoS的服务，传统构件完全由程序代码直接控制

<img src="https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/image-20220926204310806.png" alt="image-20220926204310806" style="zoom: 100%;" />

#### 服务实现方式

发现服务：UDDI、DISCO

描述服务：WSDL、XML Schema

消息格式层：SOAP、REST

编码格式层：XML (DOM， SAX) 

传输协议层：HTTP、TCP/IP 、SMTP等

<table><tr>
<td width="70%">
<img src="https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/image-20220926204606877.png" alt="image-20220926204606877" style="zoom: 100%;" />
</td>
<td>
<li>底层传输层</li>
<li>服务通信协议层</li>
<li>服务描述层</li>
<li>服务层</li>
<li>业务流程层</li>
<li>服务注册层</li>
</td>
</tr></table>

WSDL就是WebService接口对应的WSDL文件，该文件通过xml格式说明如何调用，以看作WebService的接口文档(使用说明书)。

#### ESB

<table><tr>
<td width="70%">
<img src="https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/image-20220926204753940.png" alt="image-20220926204753940" style="zoom:110%;" />
</td>
<td>
    <li>提供位置透明性的消息路由和寻址服务</li>
    <li>提供服务注册和命名的管理功能</li>
    <li>支持多种的消息传递范型</li>
    <li>支持多种可以广泛使用的传输协议</li>
    <li>支持多种数据格式及其相互转换</li>
    <li>提供日志和监控功能</li>
</td>
</tr></table>



### 微服务

微服务顾名思义，就是很小的服务，所以它属于面向服务架构的一种。

微服务架构是一种架构模式，它提倡将单一应用程序划分成一组小的服务，服务之间互相协调、互相配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务与服务间采用轻量级的通信机制互相沟通(通常是基于HTTP协议的RESTful API)。每个服务都围绕着具体业务进行构建，并且能够被独立的部署到生产环境、类生产环境等。另外，应当尽量避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建。

#### 特点

- 小，职责单一，专注于做一件事情
- 轻量级的通信机制
- 松耦合、独立部署

<img src="https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/image-20220926214018187.png" alt="image-20220926214018187" style="zoom:60%;" />

#### 优势

1. 不同于单一应用的紧耦合，所有功能都在一个进程中；微服务是松耦合，功能在不同微服务的进程中。
2. 技术异构性：可以用不同的语言，不同的数据库。
3. 弹性：灵活性强，针对不同的场景压力能给出不同的应对策略。
4. 扩展：不再需要基于整个系统扩展，可基于独立服务，按需扩展。
5. 简化部署：依托于自动化体系（DevOps）简化人工成本。
6. 与组织结构相匹配
7. 可组合性
8. 对可替代性的优化

#### 面临的挑战

1. 分布式系统的复杂度：事务一致性等各种问题。
2. 运维成本：服务和服务之间的问题定位等难度。
3. 部署自动化：需要完善的流程体系。
4. DevOps与组织结构
5. 服务器依赖测试
6. 服务间依赖管理

#### 对比SOA

| 微服务特性                   | SOA特性                                     |
| ---------------------------- | ------------------------------------------- |
| 能拆分的就拆分               | 是整体的，服务能放一起的都放一起            |
| 纵向业务划分                 | 是水平分多层                                |
| 由单一组织负责               | 按层级划分不同部门的组织负责                |
| 细粒度                       | 粗粒度                                      |
| 两句话可以解释明白           | 几百字只相当于SOA的目录                     |
| 独立的子公司                 | 类似大公司里面划分了一些业务单元(BU)        |
| 组件小                       | 存在较复杂的组件                            |
| 业务逻辑存在于每一个服务中   | 业务逻辑横跨多个业务领域                    |
| 使用轻量级的通信方式，如HTTP | 企业服务产总线(ESB)充当了服务之间通信的角色 |

| 微服务架构实现                   | SOA实现                          |
| -------------------------------- | -------------------------------- |
| 团队级，自底向上开展实施         | 企业级，自顶向下开展实施         |
| 一个系统被拆分成多个服务，粒度细 | 服务由多个子系统组成，粒度大     |
| 无集中式总线，松散的服务架构     | 企业服务总线，集中式的服务架构   |
| 集成方式简单(HTTP/REST/JSON)     | 集成方式复杂(ESB/WS/SOAP)        |
| 服务能独立部署                   | 单块架构系统，相互依赖，部署复杂 |

## 软件设计

> 软件设计包括体系结构设计、接口设计、数据设计和过程设计。
>
> - 结构设计：定义软件系统各主要部件之间的关系。
> - 数据设计：将模型转换成数据结构的定义。好的数据设计将改善程序结构和模块划分，降低过程复杂性。
> - 接口设计(人机界面设计)：软件内部，软件和操作系统间以及软件和人之间如何通信。
> - 过程设计：系统结构部件转换成软件的过程描述。

### 人机界面设计

**黄金三法则：置于用户控制之下、减少用户的记忆负担、保持界面的一致性。**

1. 置于用户控制之下

- 以不强迫用户进入不必要的或不希望的动作的方式来定义交互方式
- 提供灵活的交互
- 允许用户交互可以被中断和撤销
- 当技能级别增加时可以使交互流水化并允许定制交互
- 使用户隔离内部技术细节
- 设计应允许用户和出现在屏幕上的对象直接交互

2. 减少用户的记忆负担

- 减少对短期记忆的要求
- 建立有意义的缺省
- 定义直觉性的捷径
- 界面的视觉布局应该基于真实世界的隐喻
- 以不断进展的方式揭示信息

3. 保持界面的一致性

- 允许用户将当前任务放入有意义的语境
- 在应用系列内保持一致性
- 如过去的交互模型已建立起了用户期望，除非有迫不得已的理由，不要改变它

### 结构化设计

> 概要设计（外部设计）：功能需求分配给软件模块，确定每个模块的功能和调用关系，形成模块结构图。
>
> 详细设计（内部设计）：为每个具体任务选择适当的技术手段和处理方法。

#### 结构化设计原则

- 模块独立(高内聚、低耦合)
- 保持模块的大小适中
- 多扇入，少扇出
- 深度和宽度均不宜过高

#### 模块的四个要素

1. 输入和输出。模块的输入来源和输出去向都是同一个调用者，即一个模块从调用者那儿取得输入，进行加工后再把输出返回调用者。
2. 处理功能。指模块把输入转换成输出所做的工作。
3. 内部数据。指仅供该模块本身引用的数据。
4. 程序代码。指用来实现模块功能的程序。

### 内聚和耦合

| 内聚度 | 内聚类型           | 描述                                         |
| :----: | ------------------ | -------------------------------------------- |
|   7    | 功能内聚           | 完成一个单一功能，各个部分协同工作，缺一不可 |
|   6    | 顺序内聚           | 处理元素相关，而且必须顺序执行               |
|   5    | 通信内聚           | 所有处理元素集中在一个数据结构的区域上       |
|   4    | 过程内聚           | 处理元素相关，而且必须按特定的次序执行       |
|   3    | 瞬时内聚(时间内聚) | 所包含的任务必须在同一时间间隔内执行         |
|   2    | 逻辑内聚           | 完成逻辑上相关的一组任务                     |
|   1    | 偶然内聚(巧合内聚) | 完成一组没有关系或松散关系的任务             |

| 耦合度 | 耦合类型   | 描述                                                         |
| :----: | ---------- | ------------------------------------------------------------ |
|   1    | 非直接耦合 | 两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的 |
|   2    | 数据耦合   | 一组模块借助参数表传递简单数据                               |
|   3    | 标记耦合   | 一组模块通过参数表传递记录信息(数据结构)                     |
|   4    | 控制耦合   | 模块之间传递的信息中包含用于控制模块内部逻辑的信息           |
|   5    | 外部耦合   | 一组模块都访问同一全局简单变量，而且不是通过参数表传递该全局变量的信息 |
|   6    | 公共耦合   | 多个模块都访问同一个公共数据环境                             |
|   7    | 内部耦合   | 一个模块直接访问另一个模块的内部数据; 一个模块不通过正常入口转到另一个模块的内部;两个模块有一部分程序代码重叠; 一个模块有多个入口 |

### 面向对象设计

#### 基本过程

<img src="https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/image-20220926222403376.png" alt="image-20220926222403376" style="zoom:80%;" />

#### 设计原则

- 单一职责原则：设计目的单一的类
- 开放-封闭原则：对扩展开放，对修改封闭
- 里氏替换原则(Liskov)：子类可以替换父类
- 依赖倒置原则：要依赖于抽象，而不是具体实现；针对接口编程，不要针对实现编程
- 接口隔离原则：使用多个专门的接口比使用单一的总接口要好
- 组合重用原则：要尽量使用组合，而不是继承关系达到重用目的
- 迪米特原则(Demeter，最少知识原则)：一个对象应当对其他对象有尽可能少的了解

#### 设计模式

架构模式：软件设计中的高层决策，例如C/S结构就属于架构模式，架构模式反映了开发软件系统过程中所作的基本设计决策

设计模式：主要关注软件系统的设计，与具体的实现语言无关

惯用法：是最低层的模式，关注软件系统的设计与实现，实现时通过某种特定的程序设计语言来描述构件与构件之间的关系。每种编程语言都有它自己特定的模式，即语言的惯用法。例如引用-计数就是C++语言中的一种惯用法

### 例题

#### 例题1

下列关于用户界面设计的叙述中，错误的是( A )。
A 界面交互模型应经常进行修改
B 界面的视觉布局应该尽量与真实世界保持一致
C 所有可视信息的组织需要按照统一的设计标准
D 确保用户界面操作和使用的一致性

#### 例题2

软件设计包括了四个既独立又相互联系的活动：高质量的( B )将改善程序结构和模块划分，降低过程复杂性; ( A )的主要目标是开发一个模块化的程序结构，并表示出模块间的控制关系; ( D )描述了软件与用户之间的交互关系。
A 程序设计	B 数据设计	C 算法设计	D 过程设计
A 软件结构设计	B 数据结构设计	C 数据流设计	D 分布式设计
A 数据架构设计	B 模块化设计	C 性能设计	D人 机界面设计

#### 例题3

最少知识原则(也称为迪米特原则) 是面向对象设计原则之一，指一个软件实体应当尽可能少地与其他实体发生相互作用。这样，当一个实体被修改时，就会尽可能少地影响其他的实体。下列叙述中，( C )不符最少知识原则。
A 在类的划分上，应当尽量创建松耦合的类
B 在类的设计上，只要有可能，一个类型应当设计成不变类
C 在类的结构设计上，每个类都应当尽可能提高对其属性和方法的访问权限
D 在对其他类的引用上，一个对象对其他对象的引用应当降到最低

#### 例题4

( A )的选择是开发一个软件系统时的基本设计决策;( B )是最低层的模式，关注软件系统的设计与实现，描述了如何实现构件及构件之间的关系。引用一计数是C++管理动态资源时常用的一种( B )。
A.架构模式	B.惯用法	C.设计模式	D.分析模式
A.架构模式	B.惯用法	C.设计模式	D.分析模式
A.架构模式	B.惯用法	C.设计模式	D.分析模式
