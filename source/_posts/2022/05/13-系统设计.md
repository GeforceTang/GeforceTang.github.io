---
title: 系统设计
date: 2022-09-26 20:28:58
categories: 软考笔记
tags: 软考高级
---

## 知识点提要
> - 软件架构设计(⭐⭐⭐)
> - 人机界面设计(⭐⭐)
> - 结构化设计(⭐⭐⭐)
> - 面向对象设计(⭐⭐⭐⭐)

## 架构设计

> 软件架构 = 软件体系结构，架构设计就是需求分配，即将满足需求的职责分配到组件上。软件架构是为了解决需求分析和软件设计之间的鸿沟。

### 架构风格

架构风格反映了领域中众多系统所共有的结构和语义特性，并指导如何将各个构件有效地组织成一个完整的系统。

架构风格定义了用于描述系统的术语表和一组指导构建系统的规则。

| 五大架构风格  | 子风格                            |
| ------------- | --------------------------------- |
| 数据流风格    | 批处理、管道过滤器                |
| 调用/返回风格 | 主程序/子程序、面向对象、层次结构 |
| 独立构件风格  | 进程通信、事件驱动系统(隐式调用)  |
| 虚拟机风格    | 解释器、规则系统                  |
| 仓库风格      | 数据库系统、黑板系统、超文本系统  |

## 软件设计

> 软件设计包括体系结构设计、接口设计、数据设计和过程设计。
>
> - 结构设计：定义软件系统各主要部件之间的关系。
> - 数据设计：将模型转换成数据结构的定义。好的数据设计将改善程序结构和模块划分，降低过程复杂性。
> - 接口设计(人机界面设计)：软件内部，软件和操作系统间以及软件和人之间如何通信。
> - 过程设计：系统结构部件转换成软件的过程描述。

### 人机界面设计

**黄金三法则：置于用户控制之下、减少用户的记忆负担、保持界面的一致性。**

1. 置于用户控制之下

- 以不强迫用户进入不必要的或不希望的动作的方式来定义交互方式
- 提供灵活的交互
- 允许用户交互可以被中断和撤销
- 当技能级别增加时可以使交互流水化并允许定制交互
- 使用户隔离内部技术细节
- 设计应允许用户和出现在屏幕上的对象直接交互

2. 减少用户的记忆负担

- 减少对短期记忆的要求
- 建立有意义的缺省
- 定义直觉性的捷径
- 界面的视觉布局应该基于真实世界的隐喻
- 以不断进展的方式揭示信息

3. 保持界面的一致性

- 允许用户将当前任务放入有意义的语境
- 在应用系列内保持一致性
- 如过去的交互模型已建立起了用户期望，除非有迫不得已的理由，不要改变它

### 结构化设计

> 概要设计（外部设计）：功能需求分配给软件模块，确定每个模块的功能和调用关系，形成模块结构图。
>
> 详细设计（内部设计）：为每个具体任务选择适当的技术手段和处理方法。

#### 结构化设计原则

- 模块独立(高内聚、低耦合)
- 保持模块的大小适中
- 多扇入，少扇出
- 深度和宽度均不宜过高

#### 模块的四个要素

1. 输入和输出。模块的输入来源和输出去向都是同一个调用者，即一个模块从调用者那儿取得输入，进行加工后再把输出返回调用者。
2. 处理功能。指模块把输入转换成输出所做的工作。
3. 内部数据。指仅供该模块本身引用的数据。
4. 程序代码。指用来实现模块功能的程序。

### 内聚和耦合

| 内聚度 | 内聚类型           | 描述                                         |
| :----: | ------------------ | -------------------------------------------- |
|   7    | 功能内聚           | 完成一个单一功能，各个部分协同工作，缺一不可 |
|   6    | 顺序内聚           | 处理元素相关，而且必须顺序执行               |
|   5    | 通信内聚           | 所有处理元素集中在一个数据结构的区域上       |
|   4    | 过程内聚           | 处理元素相关，而且必须按特定的次序执行       |
|   3    | 瞬时内聚(时间内聚) | 所包含的任务必须在同一时间间隔内执行         |
|   2    | 逻辑内聚           | 完成逻辑上相关的一组任务                     |
|   1    | 偶然内聚(巧合内聚) | 完成一组没有关系或松散关系的任务             |

| 耦合度 | 耦合类型   | 描述                                                         |
| :----: | ---------- | ------------------------------------------------------------ |
|   1    | 非直接耦合 | 两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的 |
|   2    | 数据耦合   | 一组模块借助参数表传递简单数据                               |
|   3    | 标记耦合   | 一组模块通过参数表传递记录信息(数据结构)                     |
|   4    | 控制耦合   | 模块之间传递的信息中包含用于控制模块内部逻辑的信息           |
|   5    | 外部耦合   | 一组模块都访问同一全局简单变量，而且不是通过参数表传递该全局变量的信息 |
|   6    | 公共耦合   | 多个模块都访问同一个公共数据环境                             |
|   7    | 内部耦合   | 一个模块直接访问另一个模块的内部数据; 一个模块不通过正常入口转到另一个模块的内部;两个模块有一部分程序代码重叠; 一个模块有多个入口 |

### 面向对象设计

#### 基本过程

<img src="https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/image-20220926222403376.png" alt="image-20220926222403376" style="zoom:80%;" />

#### 设计原则

- 单一职责原则：设计目的单一的类
- 开放-封闭原则：对扩展开放，对修改封闭
- 里氏替换原则(Liskov)：子类可以替换父类
- 依赖倒置原则：要依赖于抽象，而不是具体实现；针对接口编程，不要针对实现编程
- 接口隔离原则：使用多个专门的接口比使用单一的总接口要好
- 组合重用原则：要尽量使用组合，而不是继承关系达到重用目的
- 迪米特原则(Demeter，最少知识原则)：一个对象应当对其他对象有尽可能少的了解

### 设计模型

架构模式：软件设计中的高层决策，例如C/S结构就属于架构模式，架构模式反映了开发软件系统过程中所作的基本设计决策

设计模式：主要关注软件系统的设计，与具体的实现语言无关

惯用法：是最低层的模式，关注软件系统的设计与实现，实现时通过某种特定的程序设计语言来描述构件与构件之间的关系。每种编程语言都有它自己特定的模式，即语言的惯用法。例如引用-计数就是C++语言中的一种惯用法

#### 创建型

| 设计模式名称                     | 简要说明                                                     | 速记关键字     |
| -------------------------------- | ------------------------------------------------------------ | -------------- |
| 工厂方法模式（Factory Method）   | 定义一个创建对象的接口，但由子类决定需要实例化哪一个类。工方法使得子类实例化的过程推迟 | 动态生产对象   |
| 抽象工厂模式（Abstract Factory） | 提供一个接口，可以创建一系列相关或相互依赖的对象，而无需指定它们具体的类 | 生产成系列对象 |
| 构建器模式（Builder）            | 将一个复杂类的表示与其构造相分离，使得相同的构建过程能够得出不同的表示 | 复杂对象构造   |
| 原型模式（Prototype）            | 用原型实例指定创建对象的类型，并且通过拷贝这个原型来创建新的对象 | 克隆对象       |
| 单例模式（Singleton）            | 保证一个类只有一个实例，并提供个访问它的全局访问点           | 单实例         |

#### 结构性

| 设计模式名称          | 简要说明                                                     | 速记关键字   |
| --------------------- | ------------------------------------------------------------ | ------------ |
| 适配器模式（Adapter） | 将一个类的接口转换成用户希望得到的另一种接口。它使原本不相容的接口得以协同工作 | 转换接口     |
| 桥接模式（Bridge）    | 将类的抽象部分和它的实现部分分离开来，使它们可以独立地变化   | 继承树拆分   |
| 组合模式（Composite） | 将对象组合成树型结构以表示“整体部分”的层次结构，使得用户对单个对象和组合对象的使用具有一致性 | 树形目录结构 |
| 装饰模式（Decorator） | 动态地给一个对象添加一些额外的职责。它提供了用子类扩展功能的个灵活的替代，比派生一个子类更加灵活 | 动态附加职责 |
| 外观模式（Facade）    | 定义一个高层接口，为子系统中的一组接口提供一个致的外观，从而简化了该子系统的使用 | 对外统一接口 |
| 享元模式（Flyweight） | 提供支持大量细粒度对象共享的有效方法                         | 汉字编码     |
| 代理模式（Proxy）     | 为其他对象提供一种代理以控制这个对象的访问                   | 快捷方式     |

#### 行为型

| 设计模式名称                          | 简要说明                                                     | 速记关键宇       |
| ------------------------------------- | ------------------------------------------------------------ | ---------------- |
| 职责链模式（Chain of Responsibility） | 通过给多个对象处理请求的机会，减少请求的发送者与接收者之间的耦合。将接收对象链接起来，在链中传递请求，直到有一个对象处理这个请求 | 传递职责         |
| 命令模式（Command）                   | 将个请求封装为一个对象，从而可用不同的请求对客户进行参数化，将请求排队或记录请求日志，支持可撤销的操作 | 日志记录，可撤销 |
| 解释器模式（Interpreter）             | 给定一种语言，定义它的文法表示，并定义一个解释器该解释器用来根据文法表示来解释语言中的句子 | 虚拟机的机制     |
| 迭代器模式（Iterator）                | 提供一种方法来顾序访问一个聚合对象中的各个元素，而不需要暴露该对象的内部表示 | 数据集           |
| 中介者模式（Mediator）                | 用一个中介对象来封装一系列的对象交互。它使各对象不需要显式地相互调用，从而达到低耦合，还可以独立地改变对象间的交互 | 不直接引用       |
| 备忘录模式（Memento）                 | 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，从而可以在以后将该对象恢复到原先保存的状态 | 游戏存档         |
| 观察者模式（Observer）                | 定义对象间的一种一对多的依赖关系，当个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新 | 联动             |
| 状态模式（State）                     | 允许一个对象在其内部状态改变时改变它的行为                   | 状态变成类       |
| 策略模式（Strategy）                  | 定义一系列算法，把它们一个个封装起来，并且使它们之间可互相替换，从而让算法可以独立于使用它的用户而变化 | 多方案切换       |
| 模板方法模式（Template Method）       | 定义一个操作中的算法骨架，而将些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重新定义算法的某些特定步骤 | 框架             |
| 访问者模式（Visitor）                 | 表示个作用于某对象结构中的各元素的操作，使得在不改变各元素的类的前提下定义作用于这些元素的新操作 | 数据与操作分离   |

## 例题

#### 例题1

下列关于用户界面设计的叙述中，错误的是( A )。
A 界面交互模型应经常进行修改
B 界面的视觉布局应该尽量与真实世界保持一致
C 所有可视信息的组织需要按照统一的设计标准
D 确保用户界面操作和使用的一致性

#### 例题2

软件设计包括了四个既独立又相互联系的活动：高质量的( B )将改善程序结构和模块划分，降低过程复杂性; ( A )的主要目标是开发一个模块化的程序结构，并表示出模块间的控制关系; ( D )描述了软件与用户之间的交互关系。
A 程序设计	B 数据设计	C 算法设计	D 过程设计
A 软件结构设计	B 数据结构设计	C 数据流设计	D 分布式设计
A 数据架构设计	B 模块化设计	C 性能设计	D人 机界面设计

#### 例题3

最少知识原则(也称为迪米特原则) 是面向对象设计原则之一，指一个软件实体应当尽可能少地与其他实体发生相互作用。这样，当一个实体被修改时，就会尽可能少地影响其他的实体。下列叙述中，( C )不符最少知识原则。
A 在类的划分上，应当尽量创建松耦合的类
B 在类的设计上，只要有可能，一个类型应当设计成不变类
C 在类的结构设计上，每个类都应当尽可能提高对其属性和方法的访问权限
D 在对其他类的引用上，一个对象对其他对象的引用应当降到最低

#### 例题4

( A )的选择是开发一个软件系统时的基本设计决策;( B )是最低层的模式，关注软件系统的设计与实现，描述了如何实现构件及构件之间的关系。引用一计数是C++管理动态资源时常用的一种( B )。
A.架构模式	B.惯用法	C.设计模式	D.分析模式
A.架构模式	B.惯用法	C.设计模式	D.分析模式
A.架构模式	B.惯用法	C.设计模式	D.分析模式
