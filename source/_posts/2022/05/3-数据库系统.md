---
title: 数据库系统
date: 2022-05-04 17:42:48
categories: 软考笔记
tags: 系统分析
---



## 知识点提要

> 数据库模式(⭐⭐⭐)
>
> 分布式数据库(⭐)
>
> 数据库设计阶段(⭐)
>
> 概念结构设计-ER模型(⭐)
>
> 逻辑结构设计-关系模式(⭐⭐)
>
> 关系代数(⭐⭐⭐)
>
> 规范化理论(⭐⭐⭐⭐⭐)
>
> 并发控制(⭐)
>
> 数据库的安全性(⭐)
>
> 数据库备份与恢复技术(⭐)

## 数据库模式

三级模式、二级映射。

![image-20220504183022259](https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/image-20220504183022259.png)

关系的3种类型

- 基本关系(通常又称为基本表或基表)：实际存在的表，实际存储数据的逻辑表示。
- 查询表：查询结果对应的表。
- 视图表：由基表或其他视图表导出的表，本身不独立存储，数据库只存放它的定义，常称为虚表。

### 数据库视图

它一个虚拟表(逻辑上的表)，其内容由查询定义(仅保存SQL查询语句)。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并没有真正存储这些数据，而是通过查询原始表动态生成所需要的数据。

视图的优点：
1、视图能简化用户操作
2、视图使用户能以多种角度看待同一数据
3、视图对重构数据库提供了一定程度的逻辑独立性
4、视图可以对机密数据提供安全保护

#### 物化视图

它不是传统意义上虚拟视图，是实体化视图，其本身会存储数据。同时当原始表中的数据更新时，物化视图也会更新。

（视图存在性能问题，通过物化视图来提高查询性能，但是涉及到修改更新时反而性能影响更大。所以物化视图适用于多查询少更新的场景）

## 分布式数据库

集中制数据库：传统的Oracle、SqlServer，将数据库存放在一套服务器上。

- **数据独立性**。除了数据的逻辑独立性与物理独立性外，还有数据分布独立性(分布透明性，相比于集中式数据库多的能力)。
- **集中与自治共享结合的控制结构**。各局部的DBMS可以独立地管理局部数据库，具有自治的功能。同时，系统又设有集中控制机制，协调各局部DBMS的工作，执行全局应用。
- **适当增加数据冗余度**。在不同的场地存储同一数据的多个副本，可以提高系统的可靠性和可用性，同时也能提高系统性能。
  （提高系统的**可用性**，即当系统中某个节点发生故障时，因为数据有其他副本在非故障场地上，对其他所有场地来说，数据仍然是可用的，从而保证数据的完备性。）
- **全局的一致性、可串行性和可恢复性**。

![image-20220505135710020](https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/image-20220505135710020.png)

与集中数据库的差别有：

1. 外模式多了全局概念模式；
2. 概念模式多了局部概念摸索和局部概念模式；
3. 多了分片模式和分布模式，分片模式有水平分片、垂直分片和混合分片，将分片的内容如何放置到物理节点上就是分布模式来负责做的事情。

### 分片透明性

指用户不必关心数据是如何分片的，它们对数据的操作在全局关系上进行，即如何分片对用户是透明的。

- 水平分片：将数据行进行分片，存放在不同的物理节点上。比如将数据按不同区域分开存储
- 垂直分片：将数据列进行分片，存放在不同的物理节点上。比如部分常用数据放在一起，不常用数据放一起
- 混合分片：水平+垂直分片

复制透明：用户不用关心数据库在网络中各个节点的复制情况，被复制的数据的更新都由系统自动完成。

位置透明：是指用户不必知道所操作的数据放在何处，即数据分配到哪个或哪些站点存储对用户是透明的。

局部映像透明性(逻辑透明)：是最低层次的透明性，该透明性提供数据到局部数据库的映像，即用户不必关心局部DBMS支持哪种数据模型、使用哪种数据操纵语言,数据模型和操纵语言的转换是由系统完成的。因此，局部映像透明性对异构型和同构异质的分布式数据库系统是非常重要的。

### 二阶段提交

两阶段提交协议2PC，是为了解决同一个事务在分布式数据库不同节点上的事务的一致性。

#### 2PC事务提交的两个阶段

1. 表决阶段，目的是形成一个共同的决定
2. 执行阶段，目的是实现这个协调者的决定

#### 两条全局提交规则

- 只要有一个参与者撤销事务，协调者就必须做出全局撤销决定

- 只有所有参与者都同意提交事务，协调者才能做出全局提交决定

### 例题

#### 例题1

分布式数据库系统除了包含集中式数据库系统的模式结构之外，还增加了几个模式级别，其中( D )定义分布式数据库中数据的整体逻辑结构，使得数据使用方便，如同没有分布一样。
A 分片模式	B 全局外模式	C 分布模式	D 全局概念模式

解题：

1. 分片模式体现的是数据如何切割。
2. 分布模式体现的是数据如何放置。
3. 全部外模式是用户可看到的外模式结构。

#### 列题2

在分布式数据库中包括分片透明、复制透明、位置透明和逻辑透明等基本概念，其中：( D )是指局部数据模型透明，即用户或应用程序无需知道局部场地使用的是哪种数据模型。
A 分片透明	B 复制透明	C 位置透明	D 逻辑透明

#### 例题3

分布式数据库两阶段提交协议中的两个阶段是指( C )。
A 加锁阶段、解锁阶段	B 获取阶段、运行阶段	C 表决阶段、执行阶段	D 扩展阶段、收缩阶段

## 数据库设计过程

1. 掌握数据库设计的各个阶段
2. 明白各个节点的产物内容

![image-20220505151104016](https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/image-20220505151104016.png)

1. 需求分析：
   - 数据流图：以图的形式来展示数据的流向
   - 数据字典：对数据流图中的数据做具体的解释
   - 需求说明书：对需求的说明
2. 概念结构设计：形成ER模型
3. 逻辑结构设计：将ER图转换位关系模式/关系表（涉及转换规则、规范化理论），同样也会考虑到DBMS（数据库管理系统）的一些特性，对DBMS完成选型。
4. 对数据库响应的分布形式、存储形式、访问形式等涉及到硬件及OS特性的设计，比如索引。

### 概念结构设计

#### ER图

E-R图由实体（Entity）和联系（Relation），以及实体上的属性3个部分组成。

![image-20220505155159611](https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/image-20220505155159611.png)

##### 联系的类型

两个实体之间的联系有：一对一（1：1）、一对多（1：N）、多对多（N：N）。

#### 概念设计流程

解决ER图冲突问题，先逐个绘制ER图，再结合数据流图和数据字典进行集成，在集成过程中清除冲突。

![image-20220505161632423](https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/image-20220505161632423.png)

##### 集成的方法:

- 多个局部E-R图一次集成。
- 逐步集成，用累加的方式-次集成两个局部E-R。

##### 集成产生的冲突及解决办法:

- 属性冲突：包括属性域冲突和属性取值冲突。
- 命名冲突：包括同名异义和异名同义。
- 结构冲突：包括同-对象在不同应用中具有不同的抽象，以及同一实体在不同局部E-R图中所包含的属性个数和属性排列次序不完全相同。

### 关系模型

#### 数据模型

数据模型三要素：数据结构、数据操作、数据的约束条件。

- 层次模型：树形结构，子节点只能有一个父节点。
- 网状模型：图的形式，子节点可以有多个父节点。
- 面向对象模型：以对象为结构组装成的模型。
- 关系模型：关系模型的名称就是表名，属性就是列名，每一行数据称为元组或者纪律。表现形式如下。
  - 关系（属性）： 学生（学号，姓名，年龄，班级编号）
  - 关系（属性，依赖）：学生（U,F） U={学号，姓名，年龄，班级编号} F={学号->姓名，姓名->年龄，学号 -> 班级编号}

#### 相关概念

- 目或度：关系模式中的属性个数。
- 候选码或键：元组的唯一标识，且无冗余的属性集合。
- 主码（主键）：候选键中的任意一个。
- 主属性与非主属性：组成候选码的属性就是主属性，其它的就是非主属性。
- 外码（外键）：对外映射关系的主键。
- 全码（ALL-Key）：关系模式的所有属性组是这个关系的候选码。

#### 完整性约束

- 实体完整性约束：规定基本关系的主属性不能取空值。
- 参照完整性约束：关系与关系间的引用，其他关系的主键或空值（外键）。
- 用户自定义完整性约束：应用环境决定（比如数值大小）。
- 触发器：复杂的完整性约束，可以监听触发执行。

### 逻辑结构设计

将ER图转换为关系模型，应用关系规范化优化关系模式。

![image-20220505181311816](https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/image-20220505181311816.png)

- E-R图向关系模式的转换
  - 实体向关系模式的转换
  - 联系向关系模式的转换
- 关系模式的规范化
- 确定完整性约束(保证数据的正确性)
- 用户视图的确定(提高数据的安全性和独立性)
  - 根据数据流图确定处理过程使用的视图
  - 根据用户类别确定不同用户使用的视图
- 应用程序设计

#### 关系模式转换

ER转换关系模式基本规则：

1. 一个实体型必须转换为一个关系模式
2. 联系转关系模式

- 一对一：作为实体转换，也可以独立关系
- 一对多：作为实体转换，也可以独立关系
- 多对多：独立关系

| 关联关系         | 转换规则                                                     |
| ---------------- | ------------------------------------------------------------ |
| 一对一联系的转换 | 有两种方式<br>- 独立的关系模式：并入两端主键及联系自身属性。(主键: 任一端主键) <br>- 归并(任意一端)：并入另一端主键及联系自身属性。 (主键：保持不变) |
| 一对多联系的转换 | 有两种方式<br>- 独立的关系模式：并入两端主键及联系自身属性。(主键: 炙端主键) <br>- 归并(多端)： 并入另一端主键及联系自身属性。(主键:保持不变) |
| 多对多联系的转换 | 只有一种方式<br>- 独立的关系模式：并入两端主键及联系自身属性。(主键:两端主键的组合键) |

##### 小结

| 联系类型 | 实体<br>(独立关系模式) | 联系<br>(独立关系模式) | 联系<br>(归并关系模式) | 备注         |
| -------- | :--------------------: | :--------------------: | :--------------------: | ------------ |
| 1对1     |           ✔            |           ✔            |           ✔            | 并入任一端   |
| 1对多    |           ✔            |           ✔            |           ✔            | 并入多端     |
| 多对多   |           ✔            |           ✔            |           ✗            | 只能独立关系 |

### 例题

#### 例题1

在数据库设计的( C )阶段进行关系规范化。
A 需求分析	B 概念设计	C 逻辑设计	D 物理设计

解题：

1. 需求分析是对需求分析形成数据流图和数据字典。
2. 概念设计对需求设计的产物进一步分析形成ER模式
3. 逻辑设计是概念设计的产物ER图进一步细化，并做关系规范化。
4. 物理设计是具体物理存储、物理分布、物理访问。

#### 例题2

在数据库设计的需求分析阶段应完成包括( C )在内的文档。
A E-R图	B 关系模式	C 数据字典和数据流图	D 任务书和设计方案

解题：

1. ER图 -> 概念设计
2. 关系模式 -> 逻辑设计
3. 数据字典和数据流图 -> 需求分析

#### 例题3

某数据库中有员工关系E (员工号,姓名，部门，职称，月薪) ;产品关系P (产品号，产品名称，型号，尺寸，颜色) ;仓库关系W (仓库号，仓库名称，地址，负责人) ;库存关系I (仓库号，产品号，产品数量)。
a.若数据库设计中要求:
①仓库关系W中的“负责人”引用员工关系的员工号
②库存关系I中的“仓库号，产品号”唯一标识|中的每一个记录
③员工关系E中的职称为“工程师”的月薪不能低于3500元
则①②③依次要满足的完整性约束是( B ) 。
A 实体完整性、参照完整性、用户定义完整性
B 参照完整性、实体完整性、用户定义完整性
C 用户定义完整性、实体完整性、参照完整性
D 实体完整性、用户定义完整性、参照完整性

b.若需得到每种产品的名称和该产品的总库存量，则对应的查询语句为:
SELECT 产品名称，SUM(产品数量) FROM P，I WHERE P.产品号=I.产品号( C ) ;
A ORDER BY 产品名称
B ORDER BY 产品数量
C GROUP BY 产品名称
D GROUP BY 产品数量

#### 例题4

在数据库逻辑结构的设计中，将E-R模型转换为关系模型应遵循相关原则。对于三个不同实体集和它们之间的多对多联系m: n: p,最少可转换为（ C ）个关系模式。
A. 2	B. 3	C. 4	D. 5

#### 例题5

某企业工程项目管理数据库的部分关系模式如下所示，其中带\*的表示主键，虚下划线的表示外键。
	供应商(供应商号\*，名称，地址，电话，账号)
	项目(项目号\*，负责人\*，开工日期)
	零件(零件号\*，名称，规格，单价)
	供应(项目号\*，零件号\*，供应商号\*，供应量)
	员工(员工号\*，姓名，性别，出生日期，职位，联系方式)
其中供应关系是( D )的联系。若一个工程项目可以有多个员工参加，每个员工可以参加多个项目，则项目和员工之间是( C )联系。对项目和员工关系进行设计时，( A )设计成一个独立的关系模式。
A 2个实体之间的1 : n
B 2个实体之间的n : m
C 3个实体之间的1 : n : m
D 3个实体之间的k : n : m

A 1:1	B 1:n	C n:m	D n:1

A 多对多的联系在向关系模型转换时必须
B 多对多的联系在向关系模型转换时无须
C 只需要将一端的码并入多端，所以无须
D 不仅需要将一端的码并入多端，而且必须

## 关系代数

关系模型中的属性列，属性列的个数称之为N目，表示有多少个属性列。而数据行（元组行/记录），表示一个实例。

关系代数有：并、交、差、笛卡儿积、投影、选择、连接。

### 并、交、差

并、交、差是二元运算，2个相应的二维表运算，这两个二维表是同构的（属性列是完全一致）。

- 并：S1（123）∪ S1（145） = 12345 （可以去重）
- 交：S1（123）∩ S1（145） = 1
- 差：S1（123）- S1（145） = 23

### 笛卡儿积

差是二元运算，2个相应的二维表运算，这两个二维表不要求同构。

笛卡尔积 = S1(abc,123) × S2(aef,456) = Rx(abcaef,123456)：

- 属性目 = 两者的之和，属性名相同以s1.a和s2.a来表示。
- 元组行 = 两者的乘积，2组数据完成拼接。

### 投影

投影是一元运算，是垂直方向上做截取，也就是选择属性列。

投影 = S1(abc,123)π<sub>a,b</sub> = S1(ab,123)

### 选择

选择是一元运算，是水平方向上做截取，也就是选择数据行。

选择 = S1(abc,123)σ<sub>a='1'</sub> = S1(abc,1)

### 连接

⋈自然连接：二者之和去除重复的列，元组行取交集。

S1(abc,123) ⋈ S2(acd,256) = R(abcd,2)

自然连接和笛卡尔积可以存在等值运算，另外自然连接性能由于笛卡尔积。

### 例题

#### 例题1

若关系R、S如下图所示，则关系R与S进行自然连接运算后的元组个数和属性列数分别为( D ) ;关系代数表达式π<sub>1,4</sub>(σ<sub>3=6</sub>(RXS))与关系代数表达式( C )等价。

![image-20220506181309859](https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/image-20220506181309859.png)

A 6和6	B 4和6	C 3和6	D 3和4

A π<sub>A,D</sub> (σ<sub>C=D</sub>(RXS))
B π<sub>A,R.D</sub> (σ<sub>S.C=R.D</sub>(RXS))
C π<sub>A,R.D</sub> (σ<sub>R.C=S.D</sub>(RXS))
D π<sub>A,R.D</sub> (σ<sub>S.C=S.D</sub>(RXS)) 

解题：

1. 自然连接注意是全值匹配，R.C=S.C AND R.D=S.D。图中有3条数据是满足的，注意如果R中的CD不是74而是75则不满足。
2. 另外自然连接是会自动去重的，所以只存在ABCD 4个属性列。

#### 例题2

在关系R (A1, A2, A3) 和S (A2, A3，A4)上进行关系运算的4个等价的表达式E1、E2、E3和E4如下所示:
E1=π<sub>A1,A4</sub> (σ<sub>A2<'2018' ∧ A4='95'</sub>(R⋈S))
E2=π<sub>A1,A4</sub> (σ<sub>A2<'2018'</sub>(R) ⋈ σ<sub>A4='95'</sub>(S))
E3=π<sub>A1,A4</sub> (σ<sub>A2<'2018' ∧ R.A3=S.A3 ∧ A4='95'</sub>(RXS))
E4=π<sub>A1,A4</sub> (σ<sub>R.A3=S.A3</sub>(σ<sub>A2<'2018'</sub>)(R)Xσ<sub>A4='95'</sub>(S))
如果严格按照表达式运算顺序执行，则查询效率最高的是表达式( D )。
A E1	B E2	C E3	D E4

解题：

1. 理论上自然连接的性能由于笛卡尔积，但是前提是条件一致的情况。
2. E2是自然连接，E4是笛卡尔积。由于自然连接使用的Where条件是R.A2=S.A2 AND R.A3=S.A3，而表达式的Where条件是用的是R.A3=S.A3，少了一个条件。


#### 例题3

给定关系R(A，B，C，D,E)与S(A,B,C，F,G)，那么与表达式π<sub>1，2, 4, 6，7</sub>(σ<sub>1<6</sub> (R⋈S))等价的SQL语句如下:
SELECT ( B ) FROM R，S WHERE ( C ) ;

A R.A，R.B，R.E， S.C， G
B R.A, R.B, D, F，G
C R.A，R.B，R.D，S.C，F
D R.A， R.B， R.D， S.C， G

A R.A=S.A OR R.B=S.B OR R.C=S.C OR R.A<S.F
B R.A=S.A OR R.B=S.B OR R.C=S.C OR R.A<S.B
C R.A=S.A AND R.B=S.B AND R.C=S.C AND R.A<S.F
D R.A=S.A AND R.B=S.B AND R.C=S.C AND R.A<S.B

解题

1. π<sub>1，2, 4, 6，7</sub>(σ<sub>1<6</sub> (R⋈S))是自然连接，属性列有ABCDEFG，对应12467 = ABDFG

## 规范化理论

非规范化的关 系模式，可能存在的问题包括：数据冗余、更新异常(修改操作一致性问题)、 插入异常、删除异常。

| 学号 | 姓名 | 系号 | 系名     | 系位置 |
| ---- | ---- | ---- | -------- | ------ |
| S01  | 张三 | D01  | 计算机系 | 1号楼  |
| S02  | 李四 | D01  | 计算机系 | 1号楼  |
| S03  | 王五 | D01  | 计算机系 | 1号楼  |
| S04  | 赵六 | D02  | 信息系   | 2号楼  |
| ...  | ...  | ...  | ...      | ...    |

- 数据冗余：上表中系名和系位置，数据重复存储浪费了存储空间。
- 更新异常：数据冗余之后导致数据一致性问题，需要保证对所有冗余数据都执行对应操作。
- 插入异常：因为数据插入时，主键尚未确认导致主键为空。
- 删除异常：删除不需要数据导致需要的数据也一起被删除了。比如删除学员，会同步删除系信息，导致系信息的数据丢失。

当没有达到3NF，以上问题都可能存在。

### 基本概念

#### 函数依赖

设R(U,F)是属性U上的一个关系模式，X和Y是U的子集，r为R的任一关系，如果对于r中的任意两个元组u, V,只要有u[X]=v[X], 就有u[Y]=v[Y]，则称X函数决定Y，或称Y函数依赖于X，记为X -> Y。
$$
决定因素 -> 被决定因素
$$

##### 部分函数依赖

关系模式: R1 (A，B, C, D)，依赖集: {AB->D, A->C}

部分函数依赖：当候选键是多属性集合时，会存在部分函数依赖。

##### 传递函数依赖

关系模式: R2 (A，B，C)，依赖集: {A->B，B->C}

传递函数依赖：A -> C

#### 键

候选键：唯一标识元祖，且无冗余。

主键：候选键中的任意一个。

外键：其他关系的主键。

主属性与非主属性：组成候选码的属性就是主属性，其它的就是非主属性。

#### 求候选键

- 将关系模式的函数依赖关系用“有向图”的方式表示
- 找入度为0的属性，并以该属性集合为起点，尝试遍历有向图，若能正常遍历图中所有结点，则该属性集即为关系模式的候选键
- 若入度为0的属性集不能遍历图中所有结点，则需要尝试性的将一些中间结点(既有入度，也有出度的结点)并入入度为0的属性集中，直至该集合能遍历所有结点，集合为候选键

#### 例题

##### 例题1

给定关系R(A1, A2, A3，A4)上的函数依赖集F={A1->A2，A3->A2，A2->A3，A2->A4}, R的候选关键字为（ A ）。
A. A1	B. A1A3	C. A1A3A4	D. A1A2A3

解题：

1. 入度0：A1，入度1出度1：A2，A3，出度1：A4
2. L：A1，M：A2,A3，R：A4
3. 所以A1为候选键。

##### 例题2

关系模式P(A，B，C，D, E, F, G, H, I, J) 满足下列函数依赖: FD={ABD->E，AB->G，B->F, C->J，CJ->I, G->H}，求候选码？

解题：

1. L：A,B,C，D；	R：E,H,F,I,J
2. 只有ABCD一起，才能遍历所有节点，所以候选码为（ABCD）组合键，注意括号包起来。

##### 例题 3

关系R (A, B，C)满足下列函数依赖: F {B->C，B->A，A->BC} ，关系R的候选关键字为（ B  ）。
A. AB	B. A和B	C. A和BC	D. AC和AB

### Armstrong公理

关系模式R<U，F>来说有以下的推理规则：

A1. 自反律(Reflexivity) :若Y ∈ X ∈ U，则X->Y成立。

A2. 增广律(Augmentation) :若Z ∈ U且X->Y，则XZ->YZ成立。

A3. 传递律(Transitivity) :若X->Y且Y->Z，则X->Z成立。

根据A1，A2，A3这三条推理规则可以得到下面三条推理规则:

- 合并规则：由X->Y, X->Z,有X->YZ。	(A2，A3)

- 伪传递规则：由X->Y，WY->Z，有XW->Z。	(A2, A3)

- 分解规则：由X->Y及Z ∈ Y,有X->Z。	(A1，A3)

#### 推理过程

##### 合并规则

利用A2（增广律）和A3（传递律）推理得到：

X->Y, X->Z

1. X->Y = XX->XY;
2. X->Z = XY->YZ;
3. 所以 XX->YZ，即X->YZ

##### 伪传递规则

利用A2（增广律）和A3（传递律）推理得到：

X->Y，WY->Z

1. X->Y = XW->WY
2. WY->Z，所以XW->Z

##### 分解规则

利用A1（ 自反律）和A3（传递律）推理得到：

X->Y及Z ∈ Y 

1. Z ∈ Y 所以 Y->Z
2. X->Y 所以 X->Z

#### 例题

设关系模式R(U,F)，其中u为属性集，F是U上的一组函数依赖，那么函数依赖的公理系统(Armstrong公理系统)中的合并规则是指( C )为F所蕴涵。
A 若A->B，B->C，则A->C
B 若Y∈X∈U，则X->Y
C 若A->B，A->C，则A->BC
D 若A->B，C∈B，则A->C

解题：

A 属于传递律

B 属于自反率

C 属于合并规则

D 属于分解规则

### 范式

以分级来逐步优化，来解决 插入异常、删除异常、数据冗余。

1NF：属性值都是不可分的原子值

2NF：消除非主属性对候选键的部分依赖

3NF：消除非主属性对候选键的传递依赖

BCNF：消除主属性对候选键的部分和传递依赖

#### 第一范式

第一范式(1NF)：在关系模式R中，当且仅当所有域只包含原子值，即每个属性都是不可再分的数据项，则称关系模式R是第一范式。

简单属性和复合属性、单值属性和多值属性、NUL属性、派生属性

例如：关系模式R (系名称，高级职称人数)是否满足1NF，如果不满足，应如何调整?

#### 第二范式

第二范式(2NF)：当且仅当实体E是第一范式(1NF)，且每一个非主属性，完全依赖主键(不存在部分依赖)时，则称实体E是第二范式。

思考题：请思考该关系模式会存在哪些问题(从数据冗余、 更新异常、插入异常、删除异常这几个方面来考虑)，解决方案是什么?

当AB->B,A->C，存在部分依赖，解决方案是可以将部分依赖（AC）从表中拆分成独立表，并去除C属性列。

#### 第三范式

第三范式(3NF)：当且仅当实体E是第二范式((2NF)，且E中没有非主属性传递依赖于码时，则称实体E是第三范式。

思考题：请思考该关系模式会存在哪些问题(从数据冗余、 更新异常、插入异常、删除异常这几个方面来考虑)， 解决方案是什么?

当A->B,A->C,C->D,C->F，存在非主属性传递依赖(CDF)，解决方案将CDF拆分成独立的表，并去除DF属性列。

#### BC范式

BC范式(BCNF) : 设R是一个关系模式，F是它的依赖集，R属于BCNF当且仅当其F中每个依赖的决定因素必定包含R的某个候选码。

例：关系模式STJ (S, T, J)中，S表示学生，T表示老师，J表示课程。每一老师只教一门课程。每门课程有若干老师，某一学生选定某门课，就对应一个固定老师。

#### 例题

给定关系模式R (U，F)，其中:属性集U={A1, A2，A3，A4，A5，A6}，函数依赖集F={A1->A2，A1->A3，A3->A4, A1A5->A6}。关系模式R的候选码为( C )，由于R存在非主属性对码的部分函数依赖，所以R属于( A )。
A A1A3	B A1A4	C A1A5	D A1A6
A 1NF	B 2NF	C 3NF	D BCNF

### 模式分解

为了满足范式要求，需要对关系模式进行分解，分解的过程需要保持函数依赖，确保是无损的。

#### 保持函数依赖分解

设数据库模式p={R1，R2，...，Rk}是关系模式R的一个分解，F是R上的函数依赖集，p中每个模式Ri上的FD集是Fi。如果{F1， F2，...，Fk}与F是等价的(即相互逻辑蕴涵)，那么称分解p保持FD。

##### 例题1:

有关系模式R (A, B，C)，F= {A→B, B→C}，将其拆分为: R1 (A, B)，R2 (B, C)，保持函数依赖。

##### 例题2:

有关系模式R (A, B，C)，F= {A→B, B→C, A→C}，将其拆分为：R1 (A, B)，R2 (B，C)，保持函数依赖。

##### 例题3:

有关系模式R (A, B, C)，F= {A→B, B→C, A->C}，将其拆分为: R1 (A, B)，R2 (A，C) ，不保持函数依赖。

##### 例题4:

有关系模式R (A, B, C, D，E)，F= {A→B, D→E}，将其拆分为: R1 (A, B, C)，R2 (D, E)，保持函数依赖。

#### 无损分解

有损：不能还原。无损：可以还原。

无损联接分解：指将一个关系模式分解成若干个关系模式后，通过自然联接和投影等运算仍能还原到原来的关系模式（包括属性列和元祖记录）。

##### 案例

有关系模式：成绩(学号，姓名，课程号，课程名，分数)，函数依赖：学号->姓名，课程号->课程名，(学号，课程号)->分数

若将其分解为：
	成绩(学号，课程号，分数)
	学生(学号，姓名)
	课程(课程号，课程名)

是否为无损分解？
由于有：学号->姓名，所以：成绩(学号，课程号，分数，姓名)
由于有：课程号->课程名，所以：成绩(学号，课程号，分数，姓名，课程名)

##### 表格法

将一个具有函数依赖：学号->姓名，课程号->课程名，(学号，课程号)->分数的关系模式：成绩(学号，姓名，课程号，课程名，分数)，分解为：成绩(学号，课程号，分数)；学生(学号，姓名)；课程(课程号，课程名)。

|      | 学号 | 姓名 | 课程号 | 课程名 | 分数 |
| ---- | ---- | ---- | ------ | ------ | ---- |
| 成绩 | B    | T    | B      | T      | B    |
| 学生 | B    | B    |        |        |      |
| 课程 |      |      | B      | B      |      |

##### 公式法

定理：如果R的分解为p={R1, R2}, F为R所满足的函数依赖集合，分解p具有无损联接性的充分必要条件是：R1∩R2→(R1-R2) 或 R1∩R2→(R2,-R1)

其中，R1∩R,表示模式的交，为R1与R2中公共属性组成，R1-R2或R2-R1表示模式的差集，R1-R2,表示R1中去除R1和R2的公共属性所组成。当模式R分解成两个关系模式R1和R2时，如果R1与R2的公共属性能函数决定R1中或R2中的其它属性，这样的分解就具有无损联接性。

列如：设R=ABC，F={A→B},则分解ρ1={R1 (AB) ，R2 (AC) } 与分解p2={ R1(AB) ，R3 (BC) }是否都为无损分解?

解题：

R1∩R2=A	R1-R2=B	R2-R1=C

A→B或A→C。

R1∩R3=B	R1-R3=A	R3-R1=C

B→A或B→C。

#### 例题

##### 例题1

给出关系R (U，F)，U={A， B，C, D，E}，F={A→BC，B→D,D→E}。以下关于F说法正确的是( D )。若将关系R分解为ρ={R1 (U1,F1) ，R2 (U2，F2) }，其中: U1={A, B，C}、U2={B, D, E}，则分解ρ ( A )。
A F蕴涵A→B、A→C，但F不存在传递依赖
B F蕴涵E→A、A→C，故F存在传递依赖
C F蕴涵A→D、E→A、A→C，但F不存在传递依赖
D F蕴涵A→D、A→E、B→E， 故F存在传递依赖

A 无损连接并保持函数依赖
B 无损连接但不保持函数依赖
C 有损连接并保持函数依赖
D 有损连接但不保持函数依赖

##### 例题2

某商场商品数据库的商品关系模式P (商品代码，商品名称，供应商, 联系方式，库存量)， 函数依赖集F={商品代码→商品名称，(商品代码，供应商)→库存量，供应商→联系方式}。商品关系模式P达到( A ) ;该关系模式分解成( D )后，具有无损连接的特性，并能够保持函数依赖。
A 1NF	B 2NF	C 3NF	D BCNF

A P1 (商品代码，联系方式)，P2 (商品名称，供应商，库存量)
B P1 (商品名称，联系方式)，P2 (商品代码，供应商，库存量)
C P1 (商品代码，商品名称，联系方式)，P2 (供应商，库存量)
D P1 (商品代码，商品名称)，P2 (商品代码，供应商，库存量)，P3 (供应商，联系方式)

## 并发控制

### ACID

事务：原子性（A）、一致性（C）、隔离性（I）、持续性（D）

- 原子性(Atomicity) 是指事务包含的所有操作要么全部成功，要么全部失败回滚。这些操作是一个整体，不能部分地完成。
- 一致性(Consistency) 是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。
- 隔离性(Isolation) 是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的。
- 持久性(Durability, 永久性)是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，无论发送何种故障，都不应对其有任何影响。

### 并发引起的问题

#### 丢失更新

多个事务并发执行时，T1的事务执行结果，被T2的事务执行结果给覆盖了。

| 步骤 | T1        | T2        |
| :--: | --------- | --------- |
|  1   | 读取A=10  |           |
|  2   |           | 读取A=10  |
|  3   | A=A-5写回 |           |
|  4   |           | A=A-8写回 |

#### 不可重复读

多个事务并发执行时，一个事务在第一次读取的结果和第二次读取的结果不一致，第一次读取和第二次读取过程中数据被其他事务更新了。

| 步骤 | T1                    | T2       |
| :--: | --------------------- | -------- |
|  1   | 读A=20                |          |
|  2   | 读B=30                |          |
|  3   | 求和A+B=50            |          |
|  4   |                       | 读A=20   |
|  5   |                       | A=A+50   |
|  6   |                       | 写回A=70 |
|  7   | 读A=70                |          |
|  8   | 读B=30                |          |
|  9   | 求和A+B=100(验算不对) |          |

#### 脏数据

多个事务并发执行时，一个事务更新了数据，但在事务做了回滚处理数据恢复，但更新到回滚过程中的数据被其他数据读取到了，但是脏数据发生。

| 步骤 | T1                 | T2     |
| :--: | ------------------ | ------ |
|  1   | 读A=20             |        |
|  2   | A=A+50             |        |
|  3   | 写回A=70           |        |
|  4   |                    | 读A=70 |
|  5   | ROLLBACK A恢复为20 |        |

### 解决方案（封锁协议）

- S封锁：读锁/共享锁
- X封锁：写锁/独占/排它锁
- 一级封锁协议：事务T在修改数据R之前必须先对其加X锁，直到事务结束才释放。**可防止丢失修改**
- 二级封锁协议：一级封锁协议加上事务T在读取数据R之前先对其加S锁，读完后即可释放S锁。**可防止丢失修改，还可防止读“脏”数据**
- 三级封锁协议：一级封锁协议加上事务T在读取数据R之前先对其加S锁，直到事务结束才释放。**可防止丢失修改、防止读“脏”数据与防止数据(不可)重复读**
- 二段锁协议：可串行化的。可能发生死锁

#### 一级封锁协议

| 步骤 | T1         | T2         |
| :--: | ---------- | ---------- |
|  1   | 对A增加X锁 |            |
|  2   | 读取A=10   | 对A增加X锁 |
|  3   | A=A-5写回  | 等待       |
|  4   | 释放A的X锁 | 等待       |
|  5   |            | 读取A=5    |
|  6   |            | A=A-8写回  |
|  7   |            | 释放A的X锁 |

#### 二级封锁协议

如果T2对资源没有写回操作，那么在一级封锁协议下就不会增加X锁（没有任何锁），这样就会导致了读取到的数据为脏数据。

二级封锁协议便是在此基础上增加了读锁（S锁）来避免读取到脏数据。

#### 三级封锁协议

如果T1只有读操作（S锁），而T2有写操作会增加（X锁），这个情况下二级封锁协议因为读完就释放锁了，所以未能解决不可重复读取的问题。

三级封锁协议通过延长S锁的释放时间来解决不可重复读取问题。

## 数据库安全性

| 措施           | 说明                                                         |
| -------------- | ------------------------------------------------------------ |
| 用户标识和鉴定 | 外层的安全保护措施，可以使用用户帐户、口令及随机数检验等方式 |
| 存取控制       | 对用户进行授权，包括操作类型(如查找、 插入、删除、修改等动作)和数据对象(主要是数据范围)的权限。(Grant和Revoke) |
| 密码存储和传输 | 对远程终端信息用密码传输                                     |
| 视图的保护     | 对视图进行授权                                               |
| 审计           | 使用一个专用文件或数据库，自动将用户对数据库的所有操作记录下来 |

### 例题

数据库的安全机制中，通过提供( C )第三方开发人员调用进行数据更新，从而保证数据库的关系模式不被第三方所获取。
A 索引
B 视图
C 存储过程
D 触发器

## 数据库备份与恢复技术

### 数据库备份

冷备份也称为静态备份，是将数据库正常关闭，在停止状态下，将数据库的文件全部备份(复制)下来。

热备份也称为动态备份，是利用备份软件，在数据库正常运行的状态下，将数据库中的数据文件备份出来。

| 备份方式 | 优点                                                         | 缺点                                                         |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 冷备份   | 非常快速的备份方法(只需复制文件);容易归档(简单复制即可);容易恢复到某个时间点上(只需将文件再复制回去);能与归档方法相结合，做数据库“ 最佳状态”的恢复;低度维护，高度安全 | 单独使用时，只能提供到某一时间点上的恢复;在实施备份的全过程中，数据库必须要作备份而不能做其他工作;若磁盘空间有限，只能复制到磁带等其他外部存储设备上，速度会很慢;不能按表或按用户恢复 |
| 热备份   | 可在表空间或数据库文件级备份，备份的时间短;备份时数据库仍可使用;可达到秒级恢复(恢复到某一时间点上H);可对几乎所有数据库实体做恢复;恢复是快速的 | 不能出错，否则后果严重;若热备份不成功，所得结果不可用于时间点的恢复;因难于维护，所以要特别小心，不允许“以失败告终” |

- 完全备份：备份所有数据
- 差量备份：仅备份上一次完全备份之后变化的数据
- 增量备份：备份上一次备份之后变化的数据

日志文件：事务日志是针对数据库改变所做的记录，它可以记录针对数据库的任何操作，并将记录结果保存在独立的文件中。

| 周日 | 周一 | 周二 | 周三 | 周四 | 周五 | 周六 |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 全备 | 增备 | 增备 | 差备 | 增备 | 差备 | 增备 |

### 数据库恢复

| 故障关系               | 故障原因               | 解决方法                                                     |
| ---------------------- | ---------------------- | ------------------------------------------------------------ |
| 事务本身的可预期故障   | 本身逻辑               | 在程序中预先设置Rollback语句                                 |
| 事务本身的不可预期故障 | 算术溢出、违反存储保护 | 由DBMS的恢复子系统通过日志，撤销事务对数据库的修改，回退到事务初始状态 |
| 系统故障               | 系统停止运转           | 通常使用检查点法(系统重启时自动完成)                         |
| 介质故障               | 外存被破坏             | 一般使用日志重做业务                                         |

撤销事务(UNDO)：故障发生时未完成的事务，放入Undo撤销。

重做事务(REDO)：故障发生前已提交的事务，放入Redo重做。

### 例题

假设某证券公司的股票交易系统中有正在运行的事务，此时，若要转储该交易系统数据库中的全部数据，则应采用( B )方式。
A 静态全局转储
B 动态全局转储
C 静态增量转储
D 动态增量转储





