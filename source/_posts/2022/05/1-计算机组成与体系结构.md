---
title: 计算机组成与体系结构
date: 2022-05-01 22:45:58
categories: 软考笔记
tags: 系统分析
---

## 知识点提要
> - 编码及浮点数运算（⭐）
> - Flynn分类法（⭐）
> - CISC与RISC（⭐⭐⭐）
> - 流水线技术（⭐⭐⭐）
> - 计算机组成（⭐）
> - 存储系统（⭐⭐⭐⭐⭐）
> - 总线（⭐⭐）
> - 校验码（⭐）
> - 嵌入式系统（⭐）

## 编码及浮点数运算
> 理解即可
### 浮点数
浮点数表示：N=尾数*基数<sup>指数</sup>
- 尾数为不大于10的小数
- 基数固定为2
- 指数为纯整数

运算过程：对阶 > 尾数计算 > 结果格式化
1. 阶码统一，由小向大看齐
2. 尾数相加
3. 尾数格式化，整数位最大只能有一位（提炼到指数）

特点:
1、一般尾数用补码，阶码用移码
2、阶码的位数决定数的表示范围，位数越多范围越大
3、尾数的位数决定数的有效精度，位数越多精度越高
4、对阶时，小数向大数看齐
5、对阶是通过较小数的尾数右移实现的

### 例题
浮点数在机器中的表示形式如下所示，若阶码的长度为e，尾数的长度为m，则以下关于浮点表示的叙述中，正确的是( C )。
① e的值影响浮点数的范围，e越大，所表示的浮点数值范围越大
② e的值影响浮点数的精度，e越大，所表示的浮点数精度越高
③ m的值影响浮点数的范围，m越大，所表示的浮点数范围越大
④ m的值影响浮点数的精度，m越大，所表示的浮点数精度越高
A①③ B②③ C①④ D②④

## Flynn分类法
> 了解分类方式

从指令流（I）、数据流（D）来做分类划分。

体系结构类型 | 结构 | 关键特性 | 代表
---------|----------|---------|---------
单指令流单数据流<br>SISD | 控制部分:一个<br>处理器:一个<br>主存模块:一个 | | 单处理器系统
单指令流多数据流<br>SIMD | 控制部分:一个<br>处理器:多个<br>主存模块:多个 | 各处理器以异步的形式执行同一条指令 | 并行处理机<br>阵列处理机<br>超级向量处理机(GPU)
多指令流单数据流<br>MISD | 控制部分:一个<br>处理器:多个<br>主存模块:多个 | 被证明不可能，至少是不实际 | 目前没有，有文献称流水线计算机为此类
多指令流多数据流<br>MIMD | 控制部分:多个<br>处理器:多个<br>主存模块:多个 | 能够实现作业、任务、指令等各级全面并行 | 多核处理器(SMP、BMP、MP)<br>多处理机系统(MPP)<br>多计算机


### 例题
#### 题目1
Flynn分类法根据计算机在执行程序的过程中( A )的不同组合，将计算机分为4类。当前主流的多核计算机属于( D ) 计算机。
A.指令流和数据流	B.数据流和控制流	C.指令流和控制流	D.数据流和总线带宽
A.SISD	B.SIMD	C.MISD	D.MIMD 

#### 题目2
以下关于CPU和GPU的叙述中，错误的是( C )
A CPU适合于需要处理各种不同的数据类型、大量的分支跳转及中断等场合
B CPU利用较高的主频、高速缓存(Cache) 和分支预测等技术来执行指令
C GPU采用MISD (Multiple Instruction Single Data)并行计算架构
D GPU的特点是比CPU包含更多的计算单元和更简单的控制单元

#### 题目3
关于大规模并行处理器MPP，以下说法不正确的是( B )。
A 大多数MPP系统使用标准的CPU作为它们的处理器
B 其互连网络通常采用商用的以太网实现
C 是一种异步的分布式存储器结构的MIMD系统
D 使用特殊的硬件和软件来监控系统、检测错误并从错误中平滑地恢复


## CISC与RISC
> 识别划分

复杂指令集计算机(CISC, Complex Instruction Set Computers)
精简指令集计算机(RISC, Reduced Instruction Set Computers)

指令系统类型 | 指令 | 寻址方式 | 实现方式 | 其它
---------|----------|---------|---------|---------
CISC (复杂) | 数量多，使用频率差别大，可变长格式 | 支持多种 | 微程序控制技术(微码) | 研制周期长（x86）
RISC (精简) | 数量少，使用频率接近，定长格式，大部分为单周期指令，操作寄存器，只有Load/Store操作内存 | 支持方式少 | 增加了通用寄存器;硬布线逻辑控制为主;适合采用流水线 | 优化编译，有效支持高级语言（ARM）


### 例题
RISC (精简指令系统计算机)的特点不包括:( B )。
A 指令长度固定，指令种类尽量少
B 寻址方式尽量丰富，指令功能尽可能强，
C 增加寄存器数目，以减少访存次数
D 用硬布线电路实现指令解码，以尽快完成指令译码

## 流水线

> 掌握公式

流水线是指在程序执行时多条指令重叠进行操作的一种准并行处理实现技术。各种部件同时处理是针对不同指令而言的，它们可同时为多条指令的不同部分进行工作，以提高各部件的利用率和指令的平均执行速度。

### 流水线执行时间
流水线计算公式为: 1条指令执行时间+ (指令条数-1)*流水线周期
**流水线周期为执行时间最长的一段**

- 理论公式:

$$
(t1+2+..+tx)+(n-1)*t
$$

- 实践公式: 

$$
k*t +(n-1)*t
$$ {k:指令步骤数量，t：流水线周期}

一条指令的执行过程可以分解为取指、分析和执行三步，在取指时间t取指=3△t、分析时间t分析=2△t、执行时间t执行=4△t的情况下， 若按串行方式执行，则10条指令全部执行完需要() △t;若按流水线的方式执行，流水线周期为() △t,则10条指令全部执行完需要() △t。

- 流水线周期<sub>理论公式</sub> = 3+2+4 + (10-1)\*4 = 45△t
- 流水线周期<sub>实践公式</sub> = 3\*4 + (10-1)\*4 = 48△t

### 流水线吞吐率
流水线的吞吐率(Though Put rate, TP)是指在单位时间内流水线所完成的任务数量或输出的结果数量。计算流水线吞吐率的最基本的公式如下:
流水线吞吐率：
$$
TP = \frac{指令条数}{流水线执行时间}
$$
流水线最大吞吐率：
$$
TP~max = {\lim \atop {n \to \infty}}\frac{n}{(k + n - 1)t}=\frac{1}{t}
$$
一条指令的执行过程可以分解为取指、分析和执行三步，取指时间t取指=3△t、分析时间t分析=2△t、 执行时间t执行=4△t。10条指令的吞吐率? 最大吞吐率?

- 执行时间 = 3+2+4 + (10-1)*4 = 45
- 吞吐率 = 10/45 = 2/9
- 最大吞吐率 = 1 / 4

### 流水线加速比

完成同样一批任务， 不使用流水线所用的时间与使用流水线所用的时间之比称为流水线的加速比。计算流水线加速比的基本公式如下:
$$
S = \frac{不使用流水线执行时间}{使用流水线执行时间}
$$
**加速比是大于1的**

### 超标量流水线
简单理解为多条流水线，比如度为2，则是2条流水线。
将指令按照度来分组，以最大的组指令数为计算标准。

#### 例题
设每条指令由取指、分析、执行3个子部件完成，并且每个子部件的执行时间均为△t。若采用常规标量单流水线处理机(即该处理机的度为1)，连续执行16条指令，则共耗时(  B )△t。 若采用度为4的超标量流水线处理机，连续执行上述16条指令，则共耗时( C ) △t。
A.16    B.18	C.32    D.48
A.4 	B.5 	C.6 	D.8

## 计算机组成结构

<img src="https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E7%BB%93%E6%9E%84%E5%86%85%E9%83%A8%E5%9B%BE.png" alt="计算机组成结构内部图" style="zoom:67%;" />

- 输入输出设备统称为IO设备
- 存储系统包含主存和外存，主存也称为内存，外存也就是辅助存储器，包含了磁盘、U盘、光盘、移动硬盘等
- 连接计算机内部各个设备的线路，称之为总线；总线还区分数据总线、控制总线和地址（或指令）总线

### CPU（中央处理器）

#### 运算器

1. 算术逻辑单元ALU：数据的算术运算和逻辑运算
2. 累加寄存器AC：通用寄存器，为ALU提供一个工作区，用在暂存数据
3. 数据缓冲寄存器DR：写内存时，暂存指令或数据
4. 状态条件寄存器PSW：存状态标志与控制标志（争议:也有将其归为控制器的）

#### 控制器

1. 程序计数器PC: 存储下一条要执行指令的地址
2. 指令寄存器IR：存储即将执行的指令
3. 指令译码器ID：对指令中的操作码字段进行分析解释
4. 时序部件: 提供时序控制信号

寄存器通过汇编等低级语言可以直接操控。

#### 列题

计算机执行程序时，在一个指令周期的过程中，为了能够从内存中读指令操作码，首先是将( )的内容送到地址总线上。
A 程序计数器PC
B 指令寄存器IR
C 状态寄存器SR
D 通用寄存器GR

### 计算机结构

#### 冯·诺依曼结构

冯.诺依曼结构也称普林斯顿结构，是一种将程序指令存储器和数据存储器合并在一起的存储器结构。

特点:

1. 一般用于PC处理器，如I3，I5, I7处理器
2. 指令与数据存储器合并在一起
3. 指令与数据都通过相同的数据总线传输

#### 哈佛结构

哈佛结构是一种将程序指令存储和数据存储分开的存储器结构。哈佛结构是一种并行体系结构，它的主要特点是将程序和数据存储在不同的存储空间中，即程序存储器和数据存储器是两个独立的存储器，每个存储器独立编址、独立访问。
特点:

1. **一般用于嵌入式系统处理器(DSP) 数字信号处理(DSP， Digital Signal Processing)**
2. 指令与数据分开存储，可以并行读取，有较高数据的吞吐率
3. 有4条总线：指令和数据的数据总线与地址总线

### 嵌入式芯片

|      | 定义                                                         | 简称                 | 特点                                                         | 类比                                             |
| ---- | ------------------------------------------------------------ | -------------------- | ------------------------------------------------------------ | ------------------------------------------------ |
| DSP  | DSP芯片，也称数字信号处理器，是一种特别适 合于进行数字信号处理运算的微处理器，其主要应用是实时快速地实现各种数字信号处理算法。 | 数字信号处理器       | 适合数字信号处理运算,实时快速地实现各种数组信号处理算法。    | 做数学运算的“大脑”                               |
| SoC  | System on Chip,简称Soc,也即片上系统。从狭义角度讲，它是信息系统核心的芯片集成，是将系统关键部件集成在一块芯片上;从广义角度讲，SoC是一个微小型系统，如果说中央处理器(CPU) 是大脑，那么SoC就是包括大脑、心脏、眼睛和手的系统。 | 片上系统             | 信息系统核心的芯片集成。微小型系统。                         | 包括大脑、心脏、眼睛和手等、完成某个功能的系统。 |
| MPU  | 微机中的中央处理器(CPU) 称为微处理器(MPU)是构成微机的核心部件，也可以说是微机的心脏。它起到控制整个微型计算机工作的作用，产生控制信号对相应的部件进行控制，并执行相应的操作。 | 微处理器             | 微型机的核心部件，起到控制作用。                             | 缩小版“大脑”                                     |
| MCU  | 微控制单元(Microcontroller Unit; MCU)，又称单片微型计算机(Single Chip Microcomputer )或者单片机，是把中央处理器(Central Process Unit; CPU)的频率与规格做适当缩减，并将内存(memory)、计数器(Timer)、USB、A/D转换、UART、PLC、DMA等周边接口，甚至LCD驱动电路都整合在单一芯片上，形成芯片级的计算机，为不同的应用场合做不同组合控制。 | 单片微型计算机或单机 | 芯片级计算机。对处理器做适当缩减，并将内存、计数器等周边接口整合在单一芯片上，可以为不同的应用场合做不同控制组合。 | 缩小版“人”                                       |

#### 例题

##### 题目1

目前处理器市场中存在CPU和DSP两种类型处理器，分别用于不同场景，这两种处理器具有不同的体系结构，DSP采用( B )。
A 冯·诺伊曼结构
B 哈佛结构
C FPGA结构（可编程结构）
D 与GPU相同结构

##### 题目2

嵌入式处理器是嵌入式系统的核心部件，一般可分为嵌入式微处理器(MPU)、微控制器(MCU) 、数字信号处理器(DSP) 和片上系统(SOC)。以下叙述中，错误的是( A )。
A MPU在安全性和可靠性等方面进行增强，适用于运算量较大的智能系统
B MCU典型代表是单片机，体积小从而使功耗和成本下降
C DSP处理器对系统结构和指令进行了特殊设计，适合数字信号处理
D SOC是一个有专用目标的集成电路，其中包括完整系统并有嵌入式软件的全部内容

## 计算机存储

### 层次化存储结构

<img src="https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/存储系统-存储结构划分.png" style="zoom:67%;" />



CPU（寄存器） -> CPU（Cache） -> 主存（内存） -> 外存（硬盘、光盘、U盘等）

- 内存（DRAM）：RAM是随机存储器，特性是掉电之后数据会丢失，D（Dynamic）表示动态会定时做刷新的动作。
- ROM：只读存储器，典型的是BIOS。
- 层次化存储越靠近CPU速度越快，容量越小，成本也越高。寄存器的大小只有比特位，比如64位CPU的寄存器大小为64bit。
- Cache对程序员来说是透明的，程序员无法去操作，由CPU硬件来实现。

#### 例题

计算机采用分级存储体系的主要目的是为了( )。
A 解决主存容量不足的问题
B 提高存储器读写可靠性
C 提高外设访问效率
D 解决存储的容量、价格和速度之间的矛盾

### Cache

Cache的功能：提高CPU数据输入输出的速率，突破冯.诺依曼瓶颈，即CPU与存储系统间数据传送带宽限制。在计算机的存储系统体系中，Cache是访问速度最快的层次。

#### 局部性原理

Cache对程序员来说是透明的，使用Cache改善系统性能的依据是程序的局部性原理。

- 时间局部性：指程序中的某条指令一旦执行，不久以后该指令可能再次执行，典型原因是由于程序中存在着大量的循环操作。
- 空间局部性：指一旦程序访问了某个存储单元，不久以后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址可能集中在一定的范围内，其典型情况是程序顺序执行。
- 工作集理论:工作集是进程运行时被频繁访问的页面集合。

#### Cache命中率

如果以h代表对Cache的访问命中率，t1 表示Cache的周期时间，t表示主存储器周期时间，以读操作为例，使用“Cache+主存储器”的系统的平均周期为t3，则:

t<sub>3</sub> = h * t<sub>1</sub> + (1-h) * t<sub>2</sub>

其中，(1-h) 又称为失效率（未命中率）。

#### Cache应用

将主存的内存复制到Cache中，来提升运行性能，将内存中的块/页映射到Cache中。

##### 映射方式

- 直接相联映像：硬件电路较简单，但冲突率很高。（将主存划分成和Cache一直的区域，直接做映射关联）
- 全相联映像：电路难于设计和实现，只适用于小容量的cache,冲突率较低。
- 组相联映像：直接相联与全相联的折中。（先分区，再将区域内分组，由组号和Cache中的组号对应）

##### Cache页面淘汰算法

- 随机淘汰方法（RAND）
- 先进先出算法(FIFO)
- 近期最久未使用算法(LRU)：依托于记录上次的执行时间来判断是否淘汰
- 近期最少未使用算法（LFU）：依托于计数器来记录访问的次数来判断是否淘汰

##### Cache的读写过程算法

- 写直达：同时写Cache与内存（性能损耗比较大）
- 写回：只写Cache, 淘汰页面时，写回内存（实时性不好）
- 标记法：只写入内存，并将标志位清0，若用到此数据再次调取到Cache

### 主存编址

bit（比特位）是用来表示1|0的，8个bit = 1个字节（byte）。

字长由计算机来决定，比如一个字4bit（字长为4比特位），以4bit作为一个存储单元，对存储器中按照字长进行划分，形成存储地址，每个存储地址都由自己的地址编号。

通过小的存储器可以拼接成一个大的存储器，比如一个8*4bit的存储器。如果横着拼接会变成8\*8bit的存储器，如果竖着凭借会变成16\*4bit的存储器。

#### 存储单元

存储器有多少行，则是有多少个存储单元。

存储单元个数 = 最大地址 - 最小地址 + 1

#### 编址内容

存储器每一行存储的数据则是编址内容。

- 按字编址：存储体的存储单元是字存储单元，既最小寻址单元是一个字。（由计算机决定字长，比如64位计算机以64bit作为字长）
- 按字节编址：存储体的存储单元是字节存储单元，即最小寻址单位是一个字节（8bit）。

#### 总容量

总容量 = 存储单元个数 * 编址内容

#### 总片数

根据存储器所要求的容量和选定的存储芯片的容量，就可以计算出所需芯片的总数，即:
总片数 = 总容量 / 每片的容量

#### 例题

内存按字节编址，利用8K*4bit的存储器芯片构成84000H到8FFFFH的内存，共需( C )片。
A 6	B 8	C 12	D 24

1. 存储单元个数 = 8FFFFH - 84000H + 1 = 90000H - 84000H = C000H = 12 * 16<sup>3</sup>
2. 总容量 = 12 * 16<sup>3</sup> * 8bit = 24 * 2<sup>12</sup> * 4bit
3. 总片数 = 24 * 2<sup>12</sup> * 4bit / 8 * 2<sup>10</sup> * 4bit = 3 * 4 = 12

### 磁盘管理

#### 磁盘基础结构

<img src="https://geforce-tang.oss-cn-shanghai.aliyuncs.com/imgs/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86-%E7%A3%81%E7%9B%98%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.png" alt="存储管理-磁盘的内部结构" style="zoom: 67%;" />

- 硬盘内部有多个磁盘，磁盘正反2面均是可读的，称为磁面
- 磁面上面一圈一圈的环道，称为磁道
- 磁面上面的圆以一定角度均匀切面，称为扇区
- 所有磁面的0号磁道以立体角度来看是一个圆柱，这个圆柱称为柱面。也就是说同一个柱面编号对应所有磁盘上的磁道。
- 磁头是用来读取磁盘上的数据，所有的磁头都是固定在一个主杆上，寻道或者说查找磁道的过程就是查找柱面的过程。

##### 查找过程

1. 磁头通过跨越一个个磁道找到需要的磁道为止，这个过程称为寻道过程。
2. 磁头通过磁盘的匀速旋转来读取指定扇区中的数据。

##### 读写数据时间

**存取时间 = 寻道时间 + 等待时间**，寻道时间是指磁头移动到磁道所需的时间；等待时间为等待读写的扇区转到磁头下方所用的时间。

读取磁盘数据的时间应包括以下三个部分:
(1) 找磁道的时间。
(2) 找块(扇区)的时间，即旋转延迟时间。
(3) 数据传输时间。

##### 平均存取时间

平均存取时间(Average Access Time)是指磁头找到指定数据的平均时间，通常它是硬盘平均寻道时间和平均潜伏时间(等待时间)之和。平均存取时间最能代表硬盘找到某-数据所用的时间，数值越小越好。

平均访问时间 = 平均寻道时间 + 平均等待时间

#### 例题

某磁盘磁头从一个磁道移至另一个磁道需要10ms。文件在磁盘上非连续存放，逻辑上相邻数据块的平均移动距离为10个磁道，每块的旋转延迟时间及传输时间分别为100ms和2ms，则读取一个100块的文件需要 ( D ) ms时间。
A.10200	B.11000	C.11200	D.20200

题解：（10ms * 10 + 100ms + 2ms） * 100 = 20200

#### 磁盘分布存储

假设某磁盘的每个磁道划分成11个物理块，每块存放1个逻辑记录。逻辑记录R0，R1，。. .，R9，R10存放在同一个磁道上，记录的存放顺序如下表所示:

| 物理块   | 1             | 2             | 3             | 4             | 5             | 6             | 7             | 8             | 9             | 10            | 11             |
| -------- | ------------- | ------------- | ------------- | ------------- | ------------- | ------------- | ------------- | ------------- | ------------- | ------------- | -------------- |
| 逻辑记录 | R<sub>0</sub> | R<sub>1</sub> | R<sub>2</sub> | R<sub>3</sub> | R<sub>4</sub> | R<sub>5</sub> | R<sub>6</sub> | R<sub>7</sub> | R<sub>8</sub> | R<sub>9</sub> | R<sub>10</sub> |

如果磁盘的旋转周期为33ms,磁头当前处在R的开始处。若系统使用单缓冲区顺序处理这些记录，每个记录处理时间为3ms，则处理这11个记录的最长时间为( C ) ;若对信息存 储进行优化分布后，处理11个记录的最少时间为( B )。
A.33ms	B.336ms	C.366ms	D.376ms 
A.33ms	B.66ms	C.86ms	D.93ms

##### 题解

无分布优化：R<sub>0</sub>处理时间3ms+3ms，R<sub>1</sub>处理时间30ms+3ms+3ms .. R<sub>10</sub>  => 6ms + 36ms*10 = 366ms

优化分布：R<sub>0</sub>处理时间完成后，磁盘所在的位置正好是下一条数据的读取起始位置，通过调整存储的位置来优化读取性能。

R<sub>0</sub>3ms+3ms，R<sub>1</sub>3ms+3ms ... R<sub>11</sub>3ms+3ms = 11 * 6ms = 66ms

#### 数据缓冲区

假设磁盘块与缓冲区大小相同，每个盘块读入缓冲区的时间为15μs，由缓冲区送至用户区的时间是5μs，在用户区内系统对每块数据的处理时间为1μs,若用户需要将大小为10个磁盘块的Doc1文件逐块从磁盘读入缓冲区，并送至用户区进行处理，那么采用单缓冲区需要花费的时间为( D ) μs; 采用双缓冲区需要花费的时间为( C )μS。，
A 150	B 151	C 156	D 201
A 150	B 151	C 156	D 201

##### 题解

单缓冲区：从IO读取数据（15μs） + 缓冲区（5μs） + 处理数据（1μs），因为加载数据和处理数据是2条线并行的，之前的数据处理耗时均可以理解为并行处理完成并等待IO，所以IO数据加载耗时为（15μs+5μs）*10，处理数据的耗时为1μs，最终结果为 201μs.

简单理解，直接套用流水线的耗时计算 = 20μs + 1μs + （10 - 1）* 20μs = 201μs

双缓冲区：处理时间不变（1μs），IO数据加载耗时为（15μs+5μs）首次 + 15μs*9 = 156μs

简单理解，同样套用流水线的耗时计算 = 15μs + 5μs + 1μs + （10 - 1）* 15μs

#### 移臂调度算法

磁盘寻址的垂直寻道，是可以由计算机程序来控制，这个算法叫做移臂调度。

- 先来先服务(FCFS)：算法简单，但是性能上表现较差。
- 最短寻道时间优先(SSTF)：效率上有所优化。
- 扫描算法(SCAN)：又称电梯算法，先朝一个方向上（至内向外）将所有满足的请求都会处理，之后再对反向方向上（至外向内）的所有的请求逐一处理。
- 循环扫描(CSCAN) 算法：和电梯算法类似，但是不会反向处理而是重复之前的操作。

## 总线

### 总线的特点

- 总线是一组能为多个部件**分时共享**的公共信息传送线路。

  - 共享

  - 分时：是指同一时刻仅允许一个部件向总线发送信息，但允许多个部件同时从总线上接收相同的信息。

- 串行总线(适合长距离传输)与并行总线(适合近距离连接，不宜过长)

  - 并行总线：多条线路可以同时传递多个bit位，但是由于可能存在传递的速度不同，数据接收到的时间不一致而导致了错误，所以不建议距离过长。
  - 串行总线：只包含一条双向传输或者两条单项传输的数据线，以bit位以一定的顺序来进行串行的发送。对数据线要求不是很高，可以长距离传输。

- 单工、半双工与全双工：属于硬件上的指标。

- 总线宽度与总线带宽：如果地址总线的宽度是32位，则可以访问2<sup>32</sup>B=4GB的地址空间，宽度是指一个脉冲一次性能够通过的bit位大小，带宽而是以单位时间内通过的bit位大小。

### 总线的分类

- 数据总线(DataBus，DB) :在CPU与RAM之间来回传送需要处理或是需要储存的数据。
- 地址总线(Address Bus，AB) :用来指定在RAM (Random AccessMemory)之中储存的数据的地址。
- 控制总线(Control Bus，CB) :将微处理器控制单元(Control Unit)的信号，传送到周边设备。

### 例题

#### 例题1

挂接在总线上的多个部件，( B )。
A 只能分时向总线发送数据，并只能分时从总线接收数据
B 只能分时向总线发送数据，但可同时从总线接收数据
C 可同时向总线发送数据，并同时从总线接收数据
D 可同时向总线发送数据，但只能分时从总线接收数据

#### 例题2

下列说法中正确的是( C )。
A 半双工总线只在一个方向上传输信息，全双工总线可在两个方向上轮流传输信息
B 半双工总线只在一个方向上传输信息，全双工总线可在两个方向上同时传输信息
C 半双工总线可在两个方向上轮流传输信息，全双工总线可在两个方向上同时传输信息
D 半双工总线可在两个方向上同时传输信息，全双工总线可在两个方向上轮流传输信息

#### 例题3

以下关于串行总线的说法中，正确的是( C )。
A 串行总线一般都是全双工总线，适宜于长距离传输数据
B 串行总线传输的波特率是总线初始化时预先定义好的，使用中不可改变
C 串行总线是按位(bit) 传输数据的，其数据的正确性依赖于校验码纠正
D 串行总线的数据发送和接收是以软件查询方式工作

## 校验码

校验码主要是解决数据在电路传输过程中，遇到外界原因导致数据异常，用于一个冗余的数据校验能力。

### 奇偶校验

奇偶校验码的编码方法是:由若干位有效信息(如一个字节)，再加上一个二进制位(校验位) 组成校验码。

- 奇校验：整个校验码(有效信息位和校验位)中“1”的个数为奇数。
- 偶校验：整个校验码(有效信息位和校验位)中“1”的个数为偶数。

比如：

| 数据 | 码字 | 传输数据（奇校验） | 传输数据（偶校验） |
| ---- | ---- | ------------------ | ------------------ |
| 男   | 11   | 111                | 110                |
| 女   | 01   | 001                | 000                |

**奇偶校验，可检查1位的错误，不可纠错。**

纠错：能找到错误位置，进行取反修正。

### 循环冗余校验

**CRC校验，可检错，不可纠错。**循环冗余校验(CRC，Cyclic Redundancy Check)
CRC的编码方法是：在k位信息码之后拼接r位校验码。应用CRC码的关键是如何从k位信息位简便地得到r位校验位(编码)，以及如何从k+r位信息码判断是否出错。

冗余校验码编码规律如下:

1. 把待编码的N位有效信息表示为多项式M(X);
2. 把M(X)左移K位，得到M(X)*X<sup>K</sup>，这样空出了K位，以便拼装K位余数(即校验位) ;
3. 选取一个K+1位的产生多项式G(X),对M(X)*X<sup>K</sup>做模2除;
4. 把左移K位以后的有效信息与余数R(X)做模2加减，拼接为CRC码，此时的CRC码共有N+K位。

把接收到的CRC码用约定的生成多项式G(X)去除，如果正确，则余数为0；如果某一位出错，则余数不为0。不同的位数出错其余数不同，余数和出错位序号之间有惟一的对应关系。

#### 模2除法

模2除法是指在做除法运算的过程中不计其进位的除法，与亦或预算结果是一样的：两者相同则为false,两者不同则为ture。

比如：110-011=101，末尾虽然不够，但是不会向前一位借用值。

#### 例题

原始报文为“10111” ，其生成多项式为:“G(x) = x<sup>4</sup> + x + 1” 。对其进行CRC编码后的结果为?

1. 多项式(x<sup>4 </sup>+ x + 1) = 1\*x<sup>4</sup> + 0\*x<sup>3</sup> + 0\*x<sup>2</sup> + 1 \* x + 1 = 10011（系数二进制）

2. 被除数 = 信息位（10111） 拼接 余数位（0000）（几个0取决于多项式最高幂 或系数个数-1）
3. 执行模2除法：10111000 / 10011 = 1100
4. 结果拼接：10111 拼接 1100 = 101111100（如果结果不足4位，比如模2后结果是11，则以0补充高位结果为101110011）

### 校验算法总结

| 校验算法        | 校验码位数               | 校验码位置                          | 检错         | 纠错     | 校验方式                                                     |
| --------------- | ------------------------ | ----------------------------------- | ------------ | -------- | ------------------------------------------------------------ |
| 奇偶校验        | 1                        | 一般拼接在头部                      | 可检奇数位错 | 不可纠错 | 奇校验：最终1的个数是奇数个;<br>偶校验：最终1的个数是偶数个; |
| CRC循环冗余校验 | 生成多项式最高次幂       | 拼接在信息位尾部                    | 可检错       | 不可纠错 | **模二除法**求余数,拼接作为校验位                            |
| 海明校验        | **2<sup>r</sup>>=m+r+1** | 插入在信息位中间(2<sup>k</sup>位置) | 可检错       | 可纠错   | 分组奇偶校验                                                 |

2<sup>r</sup>>=m+r+1，m代表数据位，r位效验码位数。

比如：数据位有10位，则2<sup>r</sup>>=10+r+1，r>=4。

### 例题

若信息码字为111000110，生成多项式G(x)=x<sup>5</sup>+x<sup>3</sup>+x+1,则计算出的CRC校验码为( B )。
A 01101	B 11001	C 001101	D 011001

解题：

1. 系统二进制：101011

2. 被除数：11100011000000
3. 模2除法：11001

## 扩展知识点

### 进制转换

| 进制          | 数码            | 基数 | 位权           |
| ------------- | --------------- | ---- | -------------- |
| 十进制（D）   | 0~9             | 10   | 10<sup>k</sup> |
| 二进制（B）   | 0,1             | 2    | 2<sup>k</sup>  |
| 八进制（Ox）  | 0~7             | 8    | 8<sup>k</sup>  |
| 十六进制（H） | 0~9,A,B,C,D,E,F | 16   | 16<sup>k</sup> |

#### 按权展开法

R进制转十进制使用按权展开法

其具体操作方式为：将R进制数的每一位数值用Rk形式表示，即幂的底数是R，指数为k, k与该位和小数点之间的距离有关。当该位位于小数点左边，k值是该位和小数点之间数码的个数，而当该位位于小数点右边，k值是负值，其绝对值是该位和小数点之间数码的个数加1。

以 **数码 * 位权** 的形式展开，转换为10进制，例如：10100.01B = 1 \* 2<sup>4</sup> + 1 \* 2<sup>2</sup> + 1 \* 2<sup>-2</sup> = 16 + 4 + 0.25 = 20.25 

#### 短除法

十进制转R进制使用短除法（除基取余法）

例如：将94转换为二进制数，通过余数取得：1011110B

1. 94/2 = 47	余 0
2. 47/2 = 23	余 1
3. 23/2 = 11	余 1
4. 11/2 = 5	余 1
5. 5/2 = 2	余 1
6. 2/2 = 1	余 0
7. 1/2 = 0	余 1

例如：将94转换为十六进制数，通过余数取得：5EH

1. 94/16 = 5	余 E
2. 5/16 = 0	余 5

#### 减法

十进制转二进制使用减法。

- 2<sup>0</sup> = 1
- 2<sup>1</sup> = 2
- 2<sup>2</sup> = 4
- 2<sup>3</sup> = 8
- 2<sup>4</sup> = 16
- 2<sup>5</sup> = 32
- 2<sup>6</sup> = 64
- 2<sup>7</sup> = 128
- 2<sup>8</sup> = 256
- 2<sup>9</sup> = 512
- 2<sup>10</sup> = 1024

例如：将94转换为二进制数。找离94最近，不超过94的进制。

1. 94 - 2<sup>6</sup> = 30
2. 30 - 2<sup>4</sup> = 14
3. 14 - 2<sup>3</sup> = 6
4. 6 - 2<sup>2</sup> = 2
5. 2 - 2<sup>1</sup> = 0

最终结果：1011110

#### 二进制转八进制

两者的对应关系（1对3），位权（421）：

- 八进制：0，1，2，3，4，5，6，7

- 二进制：000，001，010，011，100，101，110，111

例如：216Ox = 010 001 110 = 10001110B

#### 二进制转十六进制

与八进制同理，对应关系需要4位（1对4），位权（8421）：

- 十六进制：0，1，2，3，4，5，6，7，8，9，A，B，C，D，E，F
- 二进制：0000,0001,0010,0011,0100,0101,0110,0111,1000,1001,1010,1011,1100,1101,1110,1111

例如：10001110 = 8E

### 码制

| 码制 | 描述                                                         | 真值 1    | 真值 -1   | 1 +（-1）      |
| ---- | :----------------------------------------------------------- | --------- | --------- | -------------- |
| 原码 | 最高位是符号位，其余低位表示数值的绝对值                     | 0000 0001 | 1000 0001 | 1000 0010 = -2 |
| 反码 | 正数的反码与原码相同，负数的反码是其绝对值按位取反（符号位不变） | 0000 0001 | 1111 1110 | 1111 1111 = -0 |
| 补码 | 用于加减运算。正数的补码与原码相同，负数的补码是其反码末位加1（符号位不变） | 0000 0001 | 1111 1111 | 0000 0000 = 0  |
| 移码 | 用于浮点数的阶码。补码的符号位按位取反                       | 1000 0001 | 0111 1111 | 1000 0000      |

#### 数码个数

| 码制 | 定点整数                                    | 定点小数                                              | 数码个数          |
| ---- | ------------------------------------------- | ----------------------------------------------------- | ----------------- |
| 原码 | -(2<sup>n-1</sup>-1) ~ +(2<sup>n-1</sup>-1) | -(1 - 2<sup>-(n-1)</sup>) ~ +(1 - 2<sup>-(n-1)</sup>) | 2<sup>n</sup> - 1 |
| 反码 | -(2<sup>n-1</sup>-1) ~ +(2<sup>n-1</sup>-1) | -(1 - 2<sup>-(n-1)</sup>) ~ +(1 - 2<sup>-(n-1)</sup>) | 2<sup>n</sup> - 1 |
| 补码 | -2<sup>n-1</sup> ~ +(2<sup>n-1</sup>-1)     | -1 ~ +(1 - 2<sup>-(n-1)</sup>)                        | 2<sup>n</sup>     |
| 移码 | -2<sup>n-1</sup> ~ +(2<sup>n-1</sup>-1)     | -1 ~ +(1 - 2<sup>-(n-1)</sup>)                        | 2<sup>n</sup>     |

#### 定点整数

当n=8，也就是一共8个数位时。

原码：-(2<sup>7</sup>-1) ~ +(2<sup>7</sup>-1) = -127 ~ +127

转为二进制：1111 1111 ~ 0111 1111

补码：1000 0000 ~ 0111 1111

**其中-128的补码为10000000是人为规定。**

#### 定点小数

当n=8，也就是一共8个数位时。

原码：-(1 - 2<sup>-7</sup>) ~ +(1 - 2<sup>-7</sup>)

即: -0.1111111 ~+ 0.1111111

补码：-1 ~ +0.1111111

**其中-1的补码为1000 0000是人为规定。**

#### 例题

##### 例题1

采用n位补码(包含一个符号位)表示数据，可以直接表示数值( D )。
A、2<sup>n</sup>	B、-2<sup>n</sup>	C、2<sup>n-1</sup>	D、-2<sup>n-1</sup>

解题：补码允许以-0表示最小值，比如以n=3为例

1. 补码取值范围为 100 ~ 011，可以表示 -4 ~ 3
2. 2<sup>n</sup>值为8，不在范围内
3. -2<sup>n</sup>值为-8，不在范围内
4. 2<sup>n-1</sup>值为4，不在范围内
5. -2<sup>n-1</sup>值为-4，在范围内

##### 例题2

如果“2X”的补码是“90H” ，那么X的真值是( B )。
A、72	B、-56	C、56	D、111

解题：

1. 90H 的二进制表示 1001 0000
2. 1001 0000 的反码为 1000 1111
3. 1000 1111 的原码为 1111 0000
4. 1111 0000 的真值为 - (2<sup>6</sup> + 2<sup>5</sup> + 2<sup>4</sup>) = -(16 + 32 + 64) = -112
5. 2X = -112 ; X = -56

### 浮点数表示

浮点数N = 尾数 * 基数<sup>指数</sup>

同十进制科学计数法：1.26 * e<sup>6</sup>，尾数部分是定点小数，整数部分是定点整数。

#### 例题

##### 例题1

浮点数能够表示的数的范围是由其( B )的位数决定的。
A、尾数	B、阶码	C、数符	D、阶符

解题：

1. 阶符是阶码上的符号位（正负号），正数代表整数，负数代表小数。
2. 数符是尾数上的符号位（正负号），正数代表正数，负数代表负数。

##### 例题2

以下关于两个浮点数相加运算的叙述中，正确的是( B )
A、首先进行对阶，阶码大的向阶码小的对齐
B、首先进行对阶，阶码小的向阶码大的对齐
C、不需要对阶，直接将尾数相加
D、不需要对阶，直接将阶码相加

##### 例题3

设16位浮点数，其中阶符1位、阶码值6位、数符1位、尾数8位。若阶码用移码表示，尾数用补码表示，则该浮点数所能表示的数值范围是( B )。
A. -2<sup>64</sup> ~ (1-2<sup>-8</sup>) 2<sup>64</sup>
B. -2<sup>63</sup> ~ (1-2<sup>-8</sup>) 2<sup>63</sup>
C. -(1-2<sup>-8</sup>) 2<sup>64</sup> ~ (1-2<sup>-8</sup>) 2<sup>64</sup>
D. -(1-2<sup>-8</sup>) 2<sup>63</sup> ~ (1-2<sup>-8</sup>) 2<sup>63</sup>

解题：

1. 数据结构 = 数符号（1位）+ 尾数（8位）+ 阶符（1位）+阶码（6位） = 0-00000000-0-000000
2. 阶码用移码，1000 0000 = 2<sup>6</sup> = 64
3. 因为移码的特殊定义，取值范围为 -64 ~ 63。 A C答案不服。
4. 同样尾数用补码，补码的最小值为-1。所以最小范围是：-2<sup>63</sup>

### 校验码概述

解决电气数据在传输过程中顺坏导致数据异常，通过增加冗余数据来对数据完成校验。

#### 码距

码距任何一种编码都由许多码字构成，任意两个码字之间最少变化的二进制位数就称为数据校验码的码距。

例如，用4位二进制表示16种状态，则有16个不同的码字，此时码距为1。如0000与0001。

#### 奇偶校验

通过扩大码距来实现校验，将信息位+校验位实现。

比如奇校验，传递男（0），需要带来校验位1，传输数据为01来保障数据。

但是无法解决发送01，接收到10的情况，检错存在局限性。

同样不能纠错。

#### CRC循环冗余校验

CRC的编码方法是：在k位信息码之后拼接r位校验码。应用CRC码的关键是如何从k位信息位简便地得到r位校验位(编码) ，以及如何从k+r位信息码判断是否出错。

把接收到的CRC码用约定的生成多项式G(X)去除(模二除法)，如果正确，则余数为0；如果某一位出错，则余数不为0。不同的位数出错其余数不同，余数和出错位序号之间有惟一的对应关系。

#### 海明校验码

海明校验码的原理是：在有效信息位中加入几个校验位形成海明码，使码距比较均匀地拉大，并把海明码的每个二进制位分配到几个奇偶校验组中。当某一位出错后，就会引起有关的几个校验位的值发生变化，这不但可以发现错误，还能指出错误的位置，为自动纠错提供了依据。

#### 例题

##### 例题1

以下关于采用一位奇校验方法的叙述中，正确的是( C )。
A、若所有奇数位出错，则可以检测出该错误但无法纠正错误
B、若所有偶数位出错，则可以检测出该错误并加以纠正
C、若有奇数个数据位出错，则可以检测出该错误但无法纠正错误
D、若有偶数个数据位出错，则可以检测出该错误并加以纠正

##### 例题2

在( D )校验方法中，采用模2运算来构造校验位。
A、水平奇偶
B、垂直奇偶
C、海明码
D、循环冗余

##### 例题3

以下关于海明码的叙述中，正确的是( A )。
A、海明码利用奇偶性进行检错和纠错
B、海明码的码距为1
C、海明码可以检错但不能纠错
D、海明码中数据位的长度与校验位的长度必须相同

##### 例题4

海明码是一种纠错码，其方法是为需要校验的数据位增加若干校验位，使得校验位的值决定于某些被校位的数据，当被校数据出错时，可根据校验位的值的变化找到出错位，从而纠正错误。对于32位的数据，至少需要增加( D )个校验位才能构成海明码。
以10位数据为例，其海明码表示D<sub>9</sub>D<sub>8</sub>D<sub>7</sub>D<sub>6</sub>D<sub>5</sub>D<sub>4</sub>D<sub>3</sub>D<sub>2</sub>D<sub>1</sub>P<sub>3</sub>D<sub>0</sub>P<sub>2</sub>P<sub>1</sub>中，其中D<sub>i</sub>(0≤i≤9) 表示数据位，P<sub>j</sub>(1 ≤j≤4)表示校验位，数据位D<sub>9</sub>由P<sub>4</sub>、P<sub>3</sub>和P<sub>2</sub>进行校验(从右至左D<sub>9</sub>的位序为14，即等于8+4+2，因此用第8位的P<sub>4</sub>、第4位的P<sub>3</sub>和第2位的P<sub>2</sub>校验) ,数据位D<sub>5</sub>由( B )进行校验。
A.3	B.4	C.5	D.6
A.P<sub>4</sub>P<sub>1</sub>	B. P<sub>4</sub>P<sub>2</sub>	C.P<sub>4</sub>P<sub>3</sub>P<sub>1</sub>	D. P<sub>3</sub>P<sub>2</sub>P<sub>1</sub>

解题：

1. 2<sup>r</sup>>=32 + r + 1，r>5，因此选D。
2. D<sub>5</sub>的为序为10，即等于8+2，使用P<sub>4</sub>P<sub>2</sub>。